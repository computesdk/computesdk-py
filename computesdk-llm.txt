<SYSTEM>This is the full developer documentation for ComputeSDK</SYSTEM>

# Compute Blog: Learn More About Sandboxes For AI

> The Compute Blog: Expand your knowledge about sandboxes, compute, and AI agents with detailed tutorials and case studies.

# From the blog

Stay up to date with ComputeSDK's latest news and updates.

Dec 19, 2025 [how-to](#)

## [How to run your first E2B sandbox](/blog/how-to-run-your-first-e2b-sandbox/)

A step-by-step process for creating a sandbox with E2B, running a basic Vite app inside, and accessing it securely via the browser.

![](/Garrison-Snelling-sq.jpeg)

[Garrison Snelling](#)

Founder, ComputeSDK

Dec 17, 2025 [sandboxes](#)

## [Why AI builder apps use ComputeSDK](/blog/why-ai-builders-use-computesdk/)

ComputeSDK gives AI builders flexibility, removes infrastructure dependencies, and gives AI builders the tools they need.

![](/Garrison-Snelling-sq.jpeg)

[Garrison Snelling](#)

Founder, ComputeSDK

Nov 13, 2025 [sandboxes](#)

## [The Universal Sandbox Interface](/blog/november-2025-update/)

ComputeSDK is a universal sandbox interface that lets you build, deploy, and interact with sandboxes across any provider using a single, consistent API.

![](/Garrison-Snelling-sq.jpeg)

[Garrison Snelling](#)

Founder, ComputeSDK

Aug 13, 2025 [computesdk](#)

## [Introducing ComputeSDK](/blog/announcement/)

A free and open-source toolkit for running other people's code in your applications

![](/Garrison-Snelling-sq.jpeg)

[Garrison Snelling](#)

Founder, ComputeSDK

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Contact Us

> Get in touch with the ComputeSDK team

We‚Äôd love to hear from you! Whether you have questions, feedback, or need support, there are several ways to get in touch with the ComputeSDK team.

## GitHub

[Section titled ‚ÄúGitHub‚Äù](#github)

The best way to report bugs, request features, or contribute to the project is through our GitHub repository:

* **Repository**: [github.com/computesdk/computesdk](https://github.com/computesdk/computesdk)
* **Issues**: [Report bugs or request features](https://github.com/computesdk/computesdk/issues)
* **Discussions**: [Community discussions](https://github.com/computesdk/computesdk/discussions)

## Support

[Section titled ‚ÄúSupport‚Äù](#support)

For technical support and questions:

* Check our [documentation](/start/introduction) first
* Search existing [GitHub issues](https://github.com/computesdk/computesdk/issues)
* Create a new issue if you can‚Äôt find an answer

## Contributing

[Section titled ‚ÄúContributing‚Äù](#contributing)

Interested in contributing to ComputeSDK? We welcome contributions of all kinds:

* Code contributions via pull requests
* Documentation improvements
* Bug reports and feature requests
* Community support and discussions

## Business Inquiries

[Section titled ‚ÄúBusiness Inquiries‚Äù](#business-inquiries)

For business partnerships, enterprise support, or other commercial inquiries, please reach out at <garrison@computesdk.com>, or book a quick call with our CEO (he loves meeting new people) [here](https://cal.com/heygarrison/15min).

# Named Sandboxes

Named sandboxes allow you to reference sandboxes by stable, human-readable identifiers instead of provider-generated UUIDs.

## Overview

[Section titled ‚ÄúOverview‚Äù](#overview)

Instead of creating a new sandbox every time and tracking the UUID yourself, you can use `findOrCreate` to implement ‚Äúone sandbox per project‚Äù or ‚Äúone sandbox per user‚Äù patterns.

## Quick Start

[Section titled ‚ÄúQuick Start‚Äù](#quick-start)

```
import { compute } from 'computesdk';

// First call - creates new sandbox
const sandbox = await compute.sandbox.findOrCreate({
  name: 'my-app',           // Your stable identifier
  namespace: 'user-alice',  // Isolation scope
  timeout: 30 * 60 * 1000   // 30 minutes
});

// Later call - returns same sandbox
const sameBox = await compute.sandbox.findOrCreate({
  name: 'my-app',
  namespace: 'user-alice'
});

console.log(sandbox.sandboxId === sameBox.sandboxId); // true
```

## API Reference

[Section titled ‚ÄúAPI Reference‚Äù](#api-reference)

### `compute.sandbox.findOrCreate(options)`

[Section titled ‚Äúcompute.sandbox.findOrCreate(options)‚Äù](#computesandboxfindorcreateoptions)

Find existing sandbox or create new one by (namespace, name).

**Parameters:**

* `options.name` (string, required): Stable identifier for your sandbox
* `options.namespace` (string, optional): Isolation scope, defaults to `"default"`
* `options.timeout` (number, optional): Timeout in milliseconds
* `options.*` (any): Additional `CreateSandboxOptions` (runtime, templateId, etc.)

**Returns:** `Promise<ProviderSandbox>` - Same sandbox instance on repeated calls

**Example:**

```
const sandbox = await compute.sandbox.findOrCreate({
  name: 'frontend-dev',
  namespace: 'project-123',
  timeout: 3600000, // 1 hour
  runtime: 'node'
});
```

### `compute.sandbox.find(options)`

[Section titled ‚Äúcompute.sandbox.find(options)‚Äù](#computesandboxfindoptions)

Find existing sandbox without creating (returns null if not found).

**Parameters:**

* `options.name` (string, required): Sandbox name to find
* `options.namespace` (string, optional): Namespace to search in, defaults to `"default"`

**Returns:** `Promise<ProviderSandbox | null>` - Sandbox if found, null otherwise

**Example:**

```
const sandbox = await compute.sandbox.find({
  name: 'frontend-dev',
  namespace: 'project-123'
});

if (sandbox) {
  console.log('Found:', sandbox.sandboxId);
} else {
  console.log('Not found');
}
```

### `compute.sandbox.extendTimeout(sandboxId, options)`

[Section titled ‚Äúcompute.sandbox.extendTimeout(sandboxId, options)‚Äù](#computesandboxextendtimeoutsandboxid-options)

Extend the timeout/expiration of an existing sandbox.

**Parameters:**

* `sandboxId` (string, required): ID of the sandbox to extend
* `options.duration` (number, optional): Additional time to extend in milliseconds. Defaults to `900000` (15 minutes)

**Returns:** `Promise<void>`

**Example:**

```
// Extend timeout by default 15 minutes
await compute.sandbox.extendTimeout('sandbox-123');

// Extend timeout by custom duration (30 minutes)
await compute.sandbox.extendTimeout('sandbox-123', {
  duration: 30 * 60 * 1000
});

// Useful with named sandboxes
const sandbox = await compute.sandbox.findOrCreate({
  name: 'long-running-task',
  namespace: 'user-alice'
});

// Extend timeout before it expires
await compute.sandbox.extendTimeout(sandbox.sandboxId, {
  duration: 60 * 60 * 1000 // 1 hour
});
```

**Note:** Only available with gateway provider. Other providers will throw an error.

## Concepts

[Section titled ‚ÄúConcepts‚Äù](#concepts)

### Name

[Section titled ‚ÄúName‚Äù](#name)

A user-defined stable identifier for your sandbox. This can be:

* Project name: `"my-react-app"`
* Environment: `"staging"`, `"production"`
* User workspace: `"user-workspace-123"`
* Any other stable identifier meaningful to your application

**Requirements:**

* Must be provided
* Should be stable (not change over time)
* Unique within a namespace

### Namespace

[Section titled ‚ÄúNamespace‚Äù](#namespace)

An isolation scope that allows different entities to use the same name without conflicts.

**Common patterns:**

* User isolation: `namespace: "user-{userId}"`
* Organization isolation: `namespace: "org-{orgId}"`
* Multi-tenant: `namespace: "{tenantId}"`
* Global shared: `namespace: "default"` (or omit the parameter)

**Behavior:**

* Defaults to `"default"` if not provided
* Same `(namespace, name)` ‚Üí always returns the same sandbox
* Different namespaces ‚Üí different sandboxes (even with same name)

### Composite Key

[Section titled ‚ÄúComposite Key‚Äù](#composite-key)

The unique identifier is the combination of `(namespace, name)`:

```
// These create/return DIFFERENT sandboxes:
await compute.sandbox.findOrCreate({ name: 'app', namespace: 'user-1' });
await compute.sandbox.findOrCreate({ name: 'app', namespace: 'user-2' });

// These return the SAME sandbox:
await compute.sandbox.findOrCreate({ name: 'app', namespace: 'user-1' });
await compute.sandbox.findOrCreate({ name: 'app', namespace: 'user-1' });
```

## Use Cases

[Section titled ‚ÄúUse Cases‚Äù](#use-cases)

### 1. User-Scoped Development Environments

[Section titled ‚Äú1. User-Scoped Development Environments‚Äù](#1-user-scoped-development-environments)

Each user gets their own isolated sandbox per project:

```
async function getUserSandbox(userId: string, projectId: string) {
  return await compute.sandbox.findOrCreate({
    name: projectId,
    namespace: `user-${userId}`,
    timeout: 2 * 60 * 60 * 1000 // 2 hours
  });
}

// User Alice working on project-123
const aliceBox = await getUserSandbox('alice', 'project-123');

// User Bob working on same project-123
const bobBox = await getUserSandbox('bob', 'project-123');

// Different sandboxes!
console.log(aliceBox.sandboxId !== bobBox.sandboxId); // true
```

### 2. Shared Team Sandboxes

[Section titled ‚Äú2. Shared Team Sandboxes‚Äù](#2-shared-team-sandboxes)

Teams share sandboxes within an organization:

```
async function getTeamSandbox(orgId: string, environment: string) {
  return await compute.sandbox.findOrCreate({
    name: environment,
    namespace: `org-${orgId}`,
    timeout: 24 * 60 * 60 * 1000 // 24 hours
  });
}

// All team members in org-acme get same "staging" sandbox
const staging1 = await getTeamSandbox('acme', 'staging');
const staging2 = await getTeamSandbox('acme', 'staging');

console.log(staging1.sandboxId === staging2.sandboxId); // true
```

### 3. Session Persistence

[Section titled ‚Äú3. Session Persistence‚Äù](#3-session-persistence)

Reconnect to user‚Äôs sandbox across app restarts:

```
class UserSession {
  private sandbox: ProviderSandbox | null = null;

  async initialize(userId: string) {
    // Try to find existing sandbox first
    this.sandbox = await compute.sandbox.find({
      name: 'workspace',
      namespace: `user-${userId}`
    });

    if (!this.sandbox) {
      // Create new sandbox if none exists
      this.sandbox = await compute.sandbox.findOrCreate({
        name: 'workspace',
        namespace: `user-${userId}`,
        timeout: 3600000
      });
      console.log('Created new workspace');
    } else {
      console.log('Reconnected to existing workspace');
    }

    return this.sandbox;
  }
}
```

### 4. CI/CD Pipelines

[Section titled ‚Äú4. CI/CD Pipelines‚Äù](#4-cicd-pipelines)

Stable sandboxes per branch/PR:

```
async function getCISandbox(repo: string, branch: string) {
  return await compute.sandbox.findOrCreate({
    name: `ci-${branch}`,
    namespace: repo,
    timeout: 60 * 60 * 1000 // 1 hour
  });
}

// PR sandboxes persist across CI runs
const prBox = await getCISandbox('my-org/my-repo', 'pr-123');
```

## Implementation Details

[Section titled ‚ÄúImplementation Details‚Äù](#implementation-details)

### Gateway Provider

[Section titled ‚ÄúGateway Provider‚Äù](#gateway-provider)

Named sandboxes are implemented in the ComputeSDK gateway using a parent/subsandbox architecture:

1. Each unique `namespace` maps to a parent sandbox
2. Each `(namespace, name)` maps to a subsandbox within that parent
3. Gateway handles all mapping/cleanup automatically

**Storage:**

```
Redis:
  "sandbox:namespace:{workspace_id}:{namespace}" ‚Üí parent_sandbox_id
  "sandbox:name:{workspace_id}:{namespace}:{name}" ‚Üí subsandbox_id

Subsandbox metadata:
  - name
  - namespace
  - parent_sandbox_id
```

### Stale Mapping Cleanup

[Section titled ‚ÄúStale Mapping Cleanup‚Äù](#stale-mapping-cleanup)

If a sandbox is destroyed externally (timeout, manual deletion, crash), the gateway automatically:

* Detects stale mappings on next `findOrCreate` or `find` call
* Removes invalid mappings
* Creates fresh sandbox on `findOrCreate`
* Returns `null` on `find`

### Provider Support

[Section titled ‚ÄúProvider Support‚Äù](#provider-support)

Currently supported providers:

* ‚úÖ Gateway provider (via ComputeSDK edge)

Providers without support will throw:

```
Error: Provider 'e2b' does not support findOrCreate.
This feature requires gateway provider with named sandbox support.
```

## Requirements

[Section titled ‚ÄúRequirements‚Äù](#requirements)

* Gateway provider (auto-selected in zero-config mode)
* ComputeSDK edge gateway with PR #73 merged
* `COMPUTESDK_API_KEY` environment variable

## Migration Guide

[Section titled ‚ÄúMigration Guide‚Äù](#migration-guide)

### From UUID Tracking

[Section titled ‚ÄúFrom UUID Tracking‚Äù](#from-uuid-tracking)

**Before:**

```
// You tracked sandbox IDs in your database
const sandboxId = await db.getSandboxId(userId, projectId);
let sandbox;

if (sandboxId) {
  sandbox = await compute.sandbox.getById(sandboxId);
}

if (!sandbox) {
  sandbox = await compute.sandbox.create();
  await db.saveSandboxId(userId, projectId, sandbox.sandboxId);
}
```

**After:**

```
// Gateway handles mapping automatically
const sandbox = await compute.sandbox.findOrCreate({
  name: projectId,
  namespace: `user-${userId}`
});
```

### From Manual Cleanup

[Section titled ‚ÄúFrom Manual Cleanup‚Äù](#from-manual-cleanup)

**Before:**

```
// You manually cleaned up old sandbox references
const sandboxId = await db.getSandboxId(userId);
if (sandboxId) {
  try {
    sandbox = await compute.sandbox.getById(sandboxId);
  } catch (error) {
    // Sandbox died, clean up database
    await db.deleteSandboxId(userId);
  }
}
```

**After:**

```
// Gateway auto-cleans stale mappings
const sandbox = await compute.sandbox.findOrCreate({
  name: 'workspace',
  namespace: `user-${userId}`
});
```

## Limitations

[Section titled ‚ÄúLimitations‚Äù](#limitations)

* Namespace/name mappings are workspace-scoped (different workspaces can reuse names)
* Maximum timeout depends on provider (gateway enforces provider limits)
* No timeout extension after creation (set long initial timeout instead)
* Requires gateway provider (not available with direct provider usage)

## See Also

[Section titled ‚ÄúSee Also‚Äù](#see-also)

* [Gateway Provider](../providers/gateway.md)
* [Sandbox API Reference](../reference/sandbox.md)
* [Usage Examples](../../examples/named-sandbox-example.ts)

# Installation

ComputeSDK provides a unified abstraction layer for executing code in secure, isolated sandboxed environments across multiple cloud providers.



## Start Here

[Section titled ‚ÄúStart Here‚Äù](#start-here)

1. Visit <https://console.computesdk.com/register> to create an account and get your ComputeSDK API key.
2. Next create a .env file in the root of your project and add your API key (this is where you will store your API keys for each of your providers as well):

```
COMPUTESDK_API_KEY=your_api_key_here
```

## Core SDK

[Section titled ‚ÄúCore SDK‚Äù](#core-sdk)

Install the core ComputeSDK package:

```
npm install computesdk
```

## Provider Setup

[Section titled ‚ÄúProvider Setup‚Äù](#provider-setup)

### Environment Variables

[Section titled ‚ÄúEnvironment Variables‚Äù](#environment-variables)

```

# daytona
export DAYTONA_API_KEY=your_daytona_api_key_here

# e2b
export E2B_API_KEY=e2b_your_api_key_here

# modal
export MODAL_TOKEN_ID=your_modal_token_id_here
export MODAL_TOKEN_SECRET=your_modal_token_secret_here

# railway
export RAILWAY_API_KEY=your_railway_api_key_here
export RAILWAY_PROJECT_ID=your_railway_project_id_here
export RAILWAY_ENVIRONMENT_ID=your_railway_environment_id_here

# vercel
export VERCEL_TOKEN=your_vercel_token_here
export VERCEL_TEAM_ID=your_team_id_here
export VERCEL_PROJECT_ID=your_project_id_here
```

# Introduction

## What is ComputeSDK?

[Section titled ‚ÄúWhat is ComputeSDK?‚Äù](#what-is-computesdk)

ComputeSDK gives you one consistent API to control sandboxes across multiple providers. Spin up isolated environments, execute shell commands, work with filesystems, and more without worrying about vendor-specific APIs. Perfect for building AI agents that execute code, running untrusted code safely, or orchestrating cloud workloads all while remaining provider-agnostic.

## How It Works

[Section titled ‚ÄúHow It Works‚Äù](#how-it-works)

ComputeSDK operates on three core concepts:

**Sandboxes** - Isolated compute environments where code executes safely\
**Providers** - Cloud platforms hosting the sandboxes (E2B, Modal, Railway, etc.)\
**Gateway** - ComputeSDK‚Äôs orchestration layer that unifies provider APIs

When you call `compute.sandbox.create()`, ComputeSDK:

1. Detects your configured provider from environment variables
2. Provisions a new sandbox on that provider
3. Returns a unified interface regardless of underlying provider
4. Handles provider-specific authentication, API quirks, and errors

This means you write code once and can switch providers by changing environment variables - no code changes required.

## Why ComputeSDK?

[Section titled ‚ÄúWhy ComputeSDK?‚Äù](#why-computesdk)

üîÑ **Provider-agnostic** - Switch between Railway, E2B, Vercel, Daytona, Modal and more without code changes\
üõ°Ô∏è **Security-first** - Isolated sandboxes protect your infrastructure\
‚ö° **Developer experience** - Simple, TypeScript-native API\
üåç **Production-ready** - Used by teams building the next generation of developer tools

### Perfect for building:

[Section titled ‚ÄúPerfect for building:‚Äù](#perfect-for-building)

* **Code execution platforms** - Run user-submitted code safely
* **Educational tools** - Interactive coding environments
* **Data analysis applications** - Process code with filesystem access
* **AI-powered development tools** - Let AI agents write and execute code
* **Testing & CI/CD systems** - Isolated test environments

## Features

[Section titled ‚ÄúFeatures‚Äù](#features)

üöÄ **Multi-provider support** - Railway, E2B, Vercel, Daytona, Modal and more\
üìÅ **Filesystem operations** - Read, write, create directories\
‚ö° **Command execution** - Run shell commands directly\
üõ°Ô∏è **Type-safe** - Full TypeScript support with comprehensive error handling\
üì¶ **Simplicity** - Auto detection of providers and simple setup

## Quick Example

[Section titled ‚ÄúQuick Example‚Äù](#quick-example)

```
npm install computesdk

export COMPUTESDK_API_KEY=your_computesdk_api_key

export PROVIDER_API_KEY=your_provider_api_key
```

```
import { compute } from 'computesdk';

// computeSDK will auto detect the provider

// Create a sandbox
const sandbox = await compute.sandbox.create();

// Execute code
const result = await sandbox.runCode('print("Hello World!")');
console.log(result.output); // "Hello World!"

// Clean up
await compute.sandbox.destroy(sandbox.sandboxId);
```

## Next Steps

[Section titled ‚ÄúNext Steps‚Äù](#next-steps)

Ready to get started? Check out our [installation guide](/docs/getting-started/installation) or dive into the [quick start](/docs/getting-started/quick-start) to begin building with ComputeSDK.

# Quick Start

Welcome to ComputeSDK! This guide will get you up and running with secure, isolated code execution across multiple cloud providers using a unified TypeScript interface.



## Get an API Key

[Section titled ‚ÄúGet an API Key‚Äù](#get-an-api-key)

1. Visit <https://console.computesdk.com/register> to create an account and get your ComputeSDK API key.
2. Next create a .env file in the root of your project and add your API key (this is where you will store your API keys for each of your providers):

```
COMPUTESDK_API_KEY=your_api_key_here

PROVIDER_API_KEY=your_provider_api_key_here
```

## Installation

[Section titled ‚ÄúInstallation‚Äù](#installation)

```
npm install computesdk
```

## Basic Usage

[Section titled ‚ÄúBasic Usage‚Äù](#basic-usage)

A **sandbox** is an isolated compute environment where you can safely execute code. Each sandbox runs on your chosen cloud provider (E2B, Railway, Modal, etc.) with a unified interface. The `create()` method provisions a new sandbox, `runCode()` executes code and returns the output, and `destroy()` tears down the sandbox to free resources.

```
import { compute } from 'computesdk';


// Create a sandbox
const sandbox = await compute.sandbox.create();

// Execute code
const result = await sandbox.runCode('print("Hello World!")');
console.log(result.output); // "Hello World!"

// Clean up
await compute.sandbox.destroy(sandbox.sandboxId);
```

## Filesystem Operations

[Section titled ‚ÄúFilesystem Operations‚Äù](#filesystem-operations)

Each sandbox has its own isolated filesystem. You can read, write, and manage files using absolute paths (starting with `/`). Files persist for the sandbox lifetime and are destroyed when you call `destroy()`.

```
// Write file
await sandbox.filesystem.writeFile('/tmp/hello.py', 'print("Hello")');

// Read file
const content = await sandbox.filesystem.readFile('/tmp/hello.py');

// Create directory
await sandbox.filesystem.mkdir('/tmp/mydir');

// List directory
const files = await sandbox.filesystem.readdir('/tmp');

// Check if exists
const exists = await sandbox.filesystem.exists('/tmp/hello.py');

// Remove file/directory
await sandbox.filesystem.remove('/tmp/hello.py');
```

## Shell Commands

[Section titled ‚ÄúShell Commands‚Äù](#shell-commands)

Use `runCommand()` for shell operations, package installation, or system commands. It provides full shell access with detailed execution results including stdout, stderr, exit codes, and execution time.

```
// Run shell command
const result = await sandbox.runCommand('ls -la');
console.log(result.stdout);

// With different working directory
const result2 = await sandbox.runCommand('pwd', { cwd: '/tmp' });
```

## Error Handling

[Section titled ‚ÄúError Handling‚Äù](#error-handling)

ComputeSDK methods throw exceptions for API/network failures. For command execution errors, check the `exitCode` in the result rather than relying on exceptions. Exit code `0` indicates success, non-zero indicates failure.

```
try {
  const sandbox = await compute.sandbox.create();
  const result = await sandbox.runCode('invalid code');
} catch (error) {
  console.error('Execution failed:', error.message);
}
```

## Essential Patterns

[Section titled ‚ÄúEssential Patterns‚Äù](#essential-patterns)

### Resource Cleanup (Critical for Production)

[Section titled ‚ÄúResource Cleanup (Critical for Production)‚Äù](#resource-cleanup-critical-for-production)

Always destroy sandboxes when done to avoid resource leaks and unnecessary costs. Sandboxes consume resources until explicitly destroyed or they timeout.

```
// ‚úÖ Recommended: Use try-finally
let sandbox;
try {
  sandbox = await compute.sandbox.create();
  await sandbox.runCode('print("Hello")');
} finally {
  if (sandbox) {
    await compute.sandbox.destroy(sandbox.sandboxId);
  }
}
```

### Error Handling with Exit Codes

[Section titled ‚ÄúError Handling with Exit Codes‚Äù](#error-handling-with-exit-codes)

Commands return exit codes following Unix conventions: `0` means success, non-zero indicates failure. Always check `exitCode` rather than catching exceptions for command failures.

```
const result = await sandbox.runCommand('npm test');
if (result.exitCode !== 0) {
  console.error('Tests failed:', result.stderr);
} else {
  console.log('Tests passed!', result.stdout);
}
```

## Understanding Results

[Section titled ‚ÄúUnderstanding Results‚Äù](#understanding-results)

### Code Execution Results

[Section titled ‚ÄúCode Execution Results‚Äù](#code-execution-results)

When you call `runCode()`, you receive:

* `output`: Combined stdout/stderr from your code
* `exitCode`: `0` for success, non-zero for errors
* `language`: Detected or specified language (`'python'`, `'node'`, etc.)

```
const result = await sandbox.runCode('print("Hello")');
console.log(result.output);    // "Hello\n"
console.log(result.exitCode);  // 0
console.log(result.language);  // "python"
```

### Command Execution Results

[Section titled ‚ÄúCommand Execution Results‚Äù](#command-execution-results)

When you call `runCommand()`, you receive:

* `stdout`: Standard output (normal program output)
* `stderr`: Standard error (error messages and warnings)
* `exitCode`: `0` for success, non-zero for failures
* `durationMs`: Execution time in milliseconds

```
const result = await sandbox.runCommand('npm install');
console.log(result.stdout);      // Installation logs
console.log(result.stderr);      // Warnings or errors
console.log(result.exitCode);    // 0
console.log(result.durationMs);  // 2341
```

# LLM Documentation Files

> AI-optimized documentation files for training large language models

ComputeSDK provides AI-optimized documentation files specifically designed for training large language models (LLMs) and AI assistants. These files contain our complete documentation in a format that‚Äôs easy for AI systems to understand and use.

## Available Files

[Section titled ‚ÄúAvailable Files‚Äù](#available-files)

### [llms-small.txt](/llms-small.txt)

[Section titled ‚Äúllms-small.txt‚Äù](#llms-smalltxt)

A minimal version containing essential information about ComputeSDK, perfect for quick AI context.

### [llms-full.txt](/llms-full.txt)

[Section titled ‚Äúllms-full.txt‚Äù](#llms-fulltxt)

The complete documentation including all guides, API references, and provider information. This comprehensive file contains everything an AI needs to help users with ComputeSDK.

# Daytona

Daytona provider for ComputeSDK - Execute code in Daytona development workspaces.

## Installation & Setup

[Section titled ‚ÄúInstallation & Setup‚Äù](#installation--setup)

```
npm install computesdk

# add to .env file
COMPUTESDK_API_KEY=your_computesdk_api_key

DAYTONA_API_KEY=your_daytona_api_key
```

## Usage

[Section titled ‚ÄúUsage‚Äù](#usage)

### With ComputeSDK

[Section titled ‚ÄúWith ComputeSDK‚Äù](#with-computesdk)

```
import { compute } from 'computesdk';
// auto-detects provider from environment variables

// Create sandbox
const sandbox = await compute.sandbox.create();

// Execute code
const result = await sandbox.runCode('print("Hello from Daytona!")');
console.log(result.stdout); // "Hello from Daytona!"

// Clean up
await compute.sandbox.destroy(sandbox.sandboxId);
```

### Configuration Options

[Section titled ‚ÄúConfiguration Options‚Äù](#configuration-options)

```
interface DaytonaConfig {
  /** Daytona API key - if not provided, will use DAYTONA_API_KEY env var */
  apiKey?: string;
  /** Default runtime environment */
  runtime?: 'node' | 'python';
  /** Execution timeout in milliseconds */
  timeout?: number;
}
```

## Explicit Provider Configuration

[Section titled ‚ÄúExplicit Provider Configuration‚Äù](#explicit-provider-configuration)

If you prefer to set the provider explicitly, you can do so as follows:

```
// Set as explicit provider
const sandbox = compute({ 
  provider: 'daytona', 
  daytona: {
    daytonaApiKey: process.env.DAYTONA_API_KEY
  },
  apiKey: process.env.COMPUTESDK_API_KEY 
}).sandbox.create();
```

## Runtime Detection

[Section titled ‚ÄúRuntime Detection‚Äù](#runtime-detection)

The provider automatically detects the runtime based on code patterns:

**Python indicators:**

* `print` statements
* `import` statements
* `def` function definitions
* Python-specific syntax (`f"`, `__`, etc.)

**Default:** Node.js for all other cases

# E2B

E2B provider for ComputeSDK

## Installation & Setup

[Section titled ‚ÄúInstallation & Setup‚Äù](#installation--setup)

```
npm install computesdk

# add to .env file
COMPUTESDK_API_KEY=your_computesdk_api_key

E2B_API_KEY=your_e2b_api_key
```

## Usage

[Section titled ‚ÄúUsage‚Äù](#usage)

```
import { compute } from 'computesdk';
// auto-detects provider from environment variables

// Create sandbox
const sandbox = await compute.sandbox.create();

// Execute code
const result = await sandbox.runCode('print("Hello from E2B!")');
console.log(result.stdout); // "Hello from E2B!"

// Clean up
await compute.sandbox.destroy(sandbox.sandboxId);
```

### Configuration Options

[Section titled ‚ÄúConfiguration Options‚Äù](#configuration-options)

```
interface E2BConfig {
  /** E2B API key - if not provided, will use E2B_API_KEY env var */
  apiKey?: string;
  /** Environment template to use */
  runtime?: 'node' | 'python';
  /** Execution timeout in milliseconds */
  timeout?: number;
}
```

## Explicit Provider Configuration

[Section titled ‚ÄúExplicit Provider Configuration‚Äù](#explicit-provider-configuration)

If you prefer to set the provider explicitly, you can do so as follows:

```
// Set as explicit provider
const sandbox = compute({ 
  provider: 'e2b', 
  e2b: {
    e2bApiKey: process.env.E2B_API_KEY
  },
  apiKey: process.env.COMPUTESDK_API_KEY 
}).sandbox.create();
```

## Runtime Detection

[Section titled ‚ÄúRuntime Detection‚Äù](#runtime-detection)

The provider automatically detects the runtime based on code patterns:

**Python indicators:**

* `print` statements
* `import` statements
* `def` function definitions
* Python-specific syntax (`f"`, `__`, etc.)

**Default:** Node.js for all other cases

# Modal

Modal provider for ComputeSDK - Execute code with GPU support for machine learning workloads.

## Installation & Setup

[Section titled ‚ÄúInstallation & Setup‚Äù](#installation--setup)

```
npm install computesdk

# add to .env file
COMPUTESDK_API_KEY=your_computesdk_api_key

MODAL_TOKEN_ID=your_modal_token_id_here
MODAL_TOKEN_SECRET=your_modal_token_secret_here
```

## Usage

[Section titled ‚ÄúUsage‚Äù](#usage)

### With ComputeSDK

[Section titled ‚ÄúWith ComputeSDK‚Äù](#with-computesdk)

```
import { compute } from 'computesdk';
// auto-detects provider from environment variables

// Create sandbox
const sandbox = await compute.sandbox.create();

// Get instance
const instance = sandbox.getInstance();

// Execute code
const result = await sandbox.runCode('print("Hello from Modal!")');
console.log(result.stdout); // "Hello from Modal!"

// Clean up
await compute.sandbox.destroy(sandbox.sandboxId);
```

### Configuration Options

[Section titled ‚ÄúConfiguration Options‚Äù](#configuration-options)

```
interface ModalConfig {
  /** Modal token ID - if not provided, will use MODAL_TOKEN_ID env var */
  tokenId?: string;
  /** Modal token secret - if not provided, will use MODAL_TOKEN_SECRET env var */
  tokenSecret?: string;
  /** Runtime to use */
  runtime?: 'node' | 'python';
  /** Execution timeout in milliseconds */
  timeout?: number;
  /** Modal environment (sandbox or main) */
  environment?: string;
  /** Ports to expose (unencrypted by default) */
  ports?: number[];
}
```

## Explicit Provider Configuration

[Section titled ‚ÄúExplicit Provider Configuration‚Äù](#explicit-provider-configuration)

If you prefer to set the provider explicitly, you can do so as follows:

```
// Set as explicit provider
const sandbox = compute({ 
  provider: 'modal', 
  modal: {
    modalTokenId: process.env.MODAL_TOKEN_ID,
    modalTokenSecret: process.env.MODAL_TOKEN_SECRET
  },
  apiKey: process.env.COMPUTESDK_API_KEY 
}).sandbox.create();
```

Ports are exposed with unencrypted tunnels by default for maximum compatibility.

# Railway

Railway provider for ComputeSDK - Deploy and manage containerized sandboxes on Railway‚Äôs infrastructure.

## Installation & Setup

[Section titled ‚ÄúInstallation & Setup‚Äù](#installation--setup)

```
npm install computesdk

# add to .env file
COMPUTESDK_API_KEY=your_computesdk_api_key

RAILWAY_API_KEY=your_railway_api_key
RAILWAY_PROJECT_ID=your_railway_project_id
RAILWAY_ENVIRONMENT_ID=your_railway_environment_id
```

## Usage

[Section titled ‚ÄúUsage‚Äù](#usage)

```
import { compute } from 'computesdk';
// auto-detects provider from environment variables

// Create sandbox
const sandbox = await compute.sandbox.create();

// List all sandboxes
const sandboxes = await compute.sandbox.list();
console.log(`Active sandboxes: ${sandboxes.length}`);

// Clean up
await compute.sandbox.destroy(sandbox.sandboxId);
```

### Configuration Options

[Section titled ‚ÄúConfiguration Options‚Äù](#configuration-options)

```
interface RailwayConfig {
  /** Railway API key - if not provided, will use RAILWAY_API_KEY env var */
  apiKey?: string;
  /** Railway Project ID - if not provided, will use RAILWAY_PROJECT_ID env var */
  projectId?: string;
  /** Railway Environment ID - if not provided, will use RAILWAY_ENVIRONMENT_ID env var */
  environmentId?: string;
}
```

### Getting Your Railway Credentials

[Section titled ‚ÄúGetting Your Railway Credentials‚Äù](#getting-your-railway-credentials)

1. **API Key**: Generate a personal API token from [Railway Dashboard ‚Üí Account Settings ‚Üí Tokens](https://railway.app/account/tokens)
2. **Project ID**: Found in your Railway project URL: `https://railway.app/project/{PROJECT_ID}`
3. **Environment ID**: Available in your project‚Äôs environment settings

## Explicit Provider Configuration

[Section titled ‚ÄúExplicit Provider Configuration‚Äù](#explicit-provider-configuration)

If you prefer to set the provider explicitly, you can do so as follows:

```
// Set as explicit provider
const sandbox = compute({
  provider: 'railway',
  railway: {
    railwayApiKey: 'your_railway_api_key',
    railwayProjectId: 'your_railway_project_id',
    railwayEnvironmentId: 'your_railway_environment_id'
  },
  computesdkApiKey: 'your_computesdk_api_key'
}).sandbox.create()
```

# Vercel

Vercel provider for ComputeSDK - Execute code in globally distributed serverless environments.

## Installation & Setup

[Section titled ‚ÄúInstallation & Setup‚Äù](#installation--setup)

```
npm install computesdk

# add to .env file
COMPUTESDK_API_KEY=your_computesdk_api_key

VERCEL_TOKEN=your_vercel_token
VERCEL_TEAM_ID=your_vercel_team_id
VERCEL_PROJECT_ID=your_vercel_project_id
```

## Usage

[Section titled ‚ÄúUsage‚Äù](#usage)

```
import { compute } from 'computesdk';
// auto-detects provider from environment variables

// Create sandbox
const sandbox = await compute.sandbox.create();

// Execute code
const result = await sandbox.runCode('print("Hello from Vercel!")');
console.log(result.stdout); // "Hello from Vercel!"

// Clean up
await compute.sandbox.destroy(sandbox.sandboxId);
```

### Configuration Options

[Section titled ‚ÄúConfiguration Options‚Äù](#configuration-options)

```
interface VercelConfig {
  /** Vercel token - if not provided, will use env vars */
  token?: string;
  /** Team ID for team accounts */
  teamId?: string;
  /** Project ID */
  projectId?: string;
  /** Runtime environment */
  runtime?: 'node' | 'python';
  /** Execution timeout in milliseconds */
  timeout?: number;
}
```

## Explicit Provider Configuration

[Section titled ‚ÄúExplicit Provider Configuration‚Äù](#explicit-provider-configuration)

If you prefer to set the provider explicitly, you can do so as follows:

```
// Set as explicit provider
const sandbox = compute({
  provider: 'vercel',
  vercel: {
    vercelToken: process.env.VERCEL_TOKEN,
    vercelTeamId: process.env.VERCEL_TEAM_ID,
    vercelProjectId: process.env.VERCEL_PROJECT_ID
  },
  apiKey: process.env.COMPUTESDK_API_KEY
}).sandbox.create()
```

## Runtime Detection

[Section titled ‚ÄúRuntime Detection‚Äù](#runtime-detection)

The provider automatically detects the runtime based on code patterns:

**Python indicators:**

* `print` statements
* `import` statements
* `def` function definitions
* Python-specific syntax (`f"`, `__`, etc.)

**Default:** Node.js for all other cases

# compute

## Overview

[Section titled ‚ÄúOverview‚Äù](#overview)

The ComputeSDK is a unified interface for managing compute sandboxes. ComputeSDK supports two configuration approaches:

* **Auto-detection (Recommended)**: Set `COMPUTESDK_API_KEY` and provider-specific environment variables, and ComputeSDK automatically detects and configures your provider
* **Explicit configuration**: Use `compute.setConfig()` to manually specify provider and credentials for more control

## ComputeSDK API Key

[Section titled ‚ÄúComputeSDK API Key‚Äù](#computesdk-api-key)

1. Visit <https://console.computesdk.com/register> to create an account and get your ComputeSDK API key.
2. Next create a .env file in the root of your project and add your API key (this is where you will store your API keys for each of your providers):

```
COMPUTESDK_API_KEY=your_api_key_here
```

## Provider-specific env variables

[Section titled ‚ÄúProvider-specific env variables‚Äù](#provider-specific-env-variables)

```
PROVIDER_API_KEY=your_provider_api_key_here
```

## Install computesdk

[Section titled ‚ÄúInstall computesdk‚Äù](#install-computesdk)

```
npm install computesdk
```

***

## Configuration

[Section titled ‚ÄúConfiguration‚Äù](#configuration)

### `compute.setConfig(config)`

[Section titled ‚Äúcompute.setConfig(config)‚Äù](#computesetconfigconfig)

Explicitly configure the compute singleton with provider and authentication details. This method provides manual control over provider selection and configuration, as an alternative to the recommended auto-detection approach.

**Parameters:**

* `config` (ExplicitComputeConfig, required): Configuration object

  * `provider` (string, required): Provider name to use (e.g., ‚Äòe2b‚Äô, ‚Äòmodal‚Äô, ‚Äòrailway‚Äô, ‚Äòdaytona‚Äô, ‚Äòvercel‚Äô, ‚Äòrunloop‚Äô, ‚Äòcloudflare‚Äô, ‚Äòcodesandbox‚Äô, ‚Äòblaxel‚Äô)
  * `apiKey` (string, required): ComputeSDK API key from <https://console.computesdk.com>
  * `gatewayUrl` (string, optional): Custom gateway URL override for development or self-hosting
  * Provider-specific configurations (object, optional): Each provider accepts specific authentication and configuration options (e.g., `e2b: { apiKey: string }`, `modal: { tokenId: string, tokenSecret: string }`)

**Returns:** `void` - No return value; configures the compute singleton in place

**ExplicitComputeConfig interface:**

```
{
  provider: string;        // Required: Provider name
  apiKey: string;          // Required: ComputeSDK API key
  gatewayUrl?: string;     // Optional: Custom gateway URL
  
  // Provider-specific configurations (optional)
  [providerName]?: {
    // Provider-specific authentication and config options
    // Varies by provider - see provider documentation
  }
}
```

**Examples:**

```
import { compute } from 'computesdk';

// Basic configuration with generic provider
compute.setConfig({
  provider: 'your-provider',
  apiKey: process.env.COMPUTESDK_API_KEY,
  'your-provider': {
    apiKey: process.env.YOUR_PROVIDER_API_KEY
  }
});

// Create sandbox after configuration
const sandbox = await compute.sandbox.create();

// Configuration with environment variables
compute.setConfig({
  provider: 'your-provider',
  apiKey: process.env.COMPUTESDK_API_KEY || 'local',
  'your-provider': {
    apiKey: process.env.YOUR_PROVIDER_API_KEY,
    projectId: process.env.YOUR_PROVIDER_PROJECT_ID
  }
});

// Error handling - missing required apiKey
try {
  compute.setConfig({
    provider: 'your-provider'
    // Missing apiKey - will throw error
  });
} catch (error) {
  console.error('Configuration failed:', error.message);
  // Error: Missing ComputeSDK API key. The 'apiKey' field is required.
}
```

**Notes:**

* **Auto-detection is recommended**: For most use cases, set environment variables and let ComputeSDK auto-detect your provider configuration automatically
* `setConfig()` replaces any existing configuration, including auto-detected settings
* The `apiKey` field is required and will throw an error if missing
* Provider-specific configurations are validated based on the selected provider
* Call `setConfig()` before creating sandboxes or using other compute methods
* Supported providers: e2b, modal, railway, daytona, vercel, runloop, cloudflare, codesandbox, blaxel
* Get your ComputeSDK API key at <https://console.computesdk.com/register>



***

## `compute.sandbox` methods

[Section titled ‚Äúcompute.sandbox methods‚Äù](#computesandbox-methods)

* [compute.sandbox](./computesandbox)

## Sandbox (interface)

[Section titled ‚ÄúSandbox (interface)‚Äù](#sandbox-interface)

* [Sandbox](./sandbox)

## Events

[Section titled ‚ÄúEvents‚Äù](#events)

* [compute.events](./computeevents)

<!-- 
## Templates
- [compute.templates](./computetemplates) -->

# compute.events

Events SDK for ComputeSDK - store, retrieve, and subscribe to sandbox events in real-time.

## Installation

[Section titled ‚ÄúInstallation‚Äù](#installation)

```
npm install @computesdk/events
```

## Quick Start

[Section titled ‚ÄúQuick Start‚Äù](#quick-start)

### Storing Events (from inside a sandbox)

[Section titled ‚ÄúStoring Events (from inside a sandbox)‚Äù](#storing-events-from-inside-a-sandbox)

Use the HTTP client to store events from your sandbox code:

```
import { createEventsClient } from '@computesdk/events';

const client = createEventsClient({
  accessToken: process.env.COMPUTESDK_ACCESS_TOKEN,
});

// Store an event
const result = await client.storeEvent({
  type: 'execution.completed',
  data: {
    exitCode: 0,
    duration: 1234,
    output: 'Hello, World!',
  },
});

console.log('Event stored:', result.eventId);
```

### Retrieving Events (from your application)

[Section titled ‚ÄúRetrieving Events (from your application)‚Äù](#retrieving-events-from-your-application)

Use your API key to retrieve historical events:

```
import { createEventsClient } from '@computesdk/events';

const client = createEventsClient({
  apiKey: process.env.COMPUTESDK_API_KEY,
});

// Get all events for a sandbox
const events = await client.getEvents('sandbox-123');

// Filter by type
const execEvents = await client.getEvents('sandbox-123', {
  type: 'execution.completed',
});

// Get events since a timestamp
const recentEvents = await client.getEvents('sandbox-123', {
  since: Date.now() - 3600000, // Last hour
  limit: 50,
});

for (const event of events) {
  console.log(`[${event.type}] ${JSON.stringify(event.data)}`);
}
```

### Real-time Streaming (Node.js)

[Section titled ‚ÄúReal-time Streaming (Node.js)‚Äù](#real-time-streaming-nodejs)

Subscribe to events in real-time using the Pub/Sub client:

```
import { createPubSubClient } from '@computesdk/events';

const pubsub = createPubSubClient({
  accessToken: process.env.COMPUTESDK_ACCESS_TOKEN,
  sandboxId: 'sandbox-123',
});

// Listen for events
pubsub.on('event', (event) => {
  console.log(`Received: ${event.type}`, event.data);
});

pubsub.on('connect', () => {
  console.log('Connected to event stream');
});

pubsub.on('disconnect', () => {
  console.log('Disconnected (will auto-reconnect)');
});

pubsub.on('error', (error) => {
  console.error('Connection error:', error);
});

// Connect and start receiving events
await pubsub.connect();

// Keep connection alive with periodic pings
setInterval(() => pubsub.ping(), 30000);

// Disconnect when done
await pubsub.disconnect();
```

## API Reference

[Section titled ‚ÄúAPI Reference‚Äù](#api-reference)

### EventsClient

[Section titled ‚ÄúEventsClient‚Äù](#eventsclient)

HTTP client for storing and retrieving events.

#### Constructor Options

[Section titled ‚ÄúConstructor Options‚Äù](#constructor-options)

```
interface EventsClientConfig {
  /** Gateway base URL (default: "https://events.computesdk.com") */
  gatewayUrl?: string;
  /** ComputeSDK API key (for retrieving events) */
  apiKey?: string;
  /** JWT access token (for storing events from sandbox) */
  accessToken?: string;
  /** Request timeout in milliseconds (default: 30000) */
  timeout?: number;
}
```

#### Methods

[Section titled ‚ÄúMethods‚Äù](#methods)

##### `storeEvent(options)` - Store an event (requires access token)

[Section titled ‚ÄústoreEvent(options) - Store an event (requires access token)‚Äù](#storeeventoptions---store-an-event-requires-access-token)

```
const result = await client.storeEvent({
  type: 'custom.event',
  data: { key: 'value' },
});
// Returns: { eventId, sandboxId, type, timestamp }
```

##### `getEvents(sandboxId, options?)` - Retrieve events (requires API key)

[Section titled ‚ÄúgetEvents(sandboxId, options?) - Retrieve events (requires API key)‚Äù](#geteventssandboxid-options---retrieve-events-requires-api-key)

```
const events = await client.getEvents('sandbox-123', {
  type: 'execution.completed', // Filter by type
  since: Date.now() - 3600000, // Events after timestamp (ms)
  limit: 100,                   // Max events (1-1000)
});
```

##### `setApiKey(apiKey)` - Update the API key

[Section titled ‚ÄúsetApiKey(apiKey) - Update the API key‚Äù](#setapikeyapikey---update-the-api-key)

##### `setAccessToken(token)` - Update the access token

[Section titled ‚ÄúsetAccessToken(token) - Update the access token‚Äù](#setaccesstokentoken---update-the-access-token)

### EventsPubSubClient

[Section titled ‚ÄúEventsPubSubClient‚Äù](#eventspubsubclient)

TCP client for real-time event streaming (Node.js only).

#### Constructor Options

[Section titled ‚ÄúConstructor Options‚Äù](#constructor-options-1)

```
interface PubSubClientConfig {
  /** Gateway host (default: "events.computesdk.com") */
  host?: string;
  /** Pub/Sub port (default: 6380) */
  port?: number;
  /** JWT access token for authentication */
  accessToken: string;
  /** Sandbox ID to subscribe to */
  sandboxId: string;
  /** Reconnect on disconnect (default: true) */
  autoReconnect?: boolean;
  /** Reconnect delay in milliseconds (default: 1000) */
  reconnectDelay?: number;
}
```

#### Methods

[Section titled ‚ÄúMethods‚Äù](#methods-1)

##### `connect()` - Connect and subscribe to events

[Section titled ‚Äúconnect() - Connect and subscribe to events‚Äù](#connect---connect-and-subscribe-to-events)

##### `disconnect()` - Disconnect from the server

[Section titled ‚Äúdisconnect() - Disconnect from the server‚Äù](#disconnect---disconnect-from-the-server)

##### `getState()` - Get connection state

[Section titled ‚ÄúgetState() - Get connection state‚Äù](#getstate---get-connection-state)

Returns: `'disconnected' | 'connecting' | 'connected' | 'error'`

##### `ping()` - Send a keepalive ping

[Section titled ‚Äúping() - Send a keepalive ping‚Äù](#ping---send-a-keepalive-ping)

#### Events

[Section titled ‚ÄúEvents‚Äù](#events)

```
pubsub.on('event', (event: SandboxEvent) => { ... });
pubsub.on('connect', () => { ... });
pubsub.on('disconnect', () => { ... });
pubsub.on('error', (error: Error) => { ... });
```

## Types

[Section titled ‚ÄúTypes‚Äù](#types)

### SandboxEvent

[Section titled ‚ÄúSandboxEvent‚Äù](#sandboxevent)

```
interface SandboxEvent {
  id: string;
  sandboxId: string;
  workspaceId: number;
  type: string;
  data: Record<string, unknown>;
  timestamp: number; // Unix timestamp in milliseconds
}
```

## Error Handling

[Section titled ‚ÄúError Handling‚Äù](#error-handling)

The package exports specific error classes:

```
import {
  EventsError,        // Base error class
  EventsAuthError,    // Authentication failures
  EventsNetworkError, // Network/timeout errors
  EventsPubSubError,  // Pub/Sub specific errors
} from '@computesdk/events';

try {
  await client.getEvents('sandbox-123');
} catch (error) {
  if (error instanceof EventsAuthError) {
    console.error('Check your API key');
  } else if (error instanceof EventsNetworkError) {
    console.error('Network issue:', error.message);
  }
}
```

## Environment Variables

[Section titled ‚ÄúEnvironment Variables‚Äù](#environment-variables)

The client automatically reads these environment variables:

| Variable                  | Description                     |
| ------------------------- | ------------------------------- |
| `COMPUTESDK_API_KEY`      | API key for retrieving events   |
| `COMPUTESDK_ACCESS_TOKEN` | Access token for storing events |
| `COMPUTESDK_GATEWAY_URL`  | Custom gateway URL              |
| `COMPUTESDK_PUBSUB_HOST`  | Custom pub/sub host             |
| `COMPUTESDK_PUBSUB_PORT`  | Custom pub/sub port             |

# compute.sandbox

## Overview

[Section titled ‚ÄúOverview‚Äù](#overview)

Core methods for creating, destroying, listing, and retrieving sandbox instances.

***

## `create(options?)`

[Section titled ‚Äúcreate(options?)‚Äù](#createoptions)

Create a new compute sandbox instance with auto-detected provider configuration.

**Parameters:**

* `options` (CreateSandboxOptions, optional): Configuration options for sandbox creation

  * `timeout` (number, optional): Sandbox execution timeout in milliseconds
  * `templateId` (string, optional): Provider-specific template or image identifier
  * `metadata` (Record\<string, any>, optional): Custom metadata to attach to the sandbox
  * `envs` (Record\<string, string>, optional): Environment variables to set in the sandbox
  * `name` (string, optional): Unique identifier for named sandbox functionality
  * `namespace` (string, optional): Isolation scope for named sandboxes (defaults to ‚Äúdefault‚Äù)

**Returns:** `Promise<Sandbox>` - New sandbox instance ready for code execution and commands

**Sandbox instance properties:**

* `sandboxId` (string): Unique identifier for the sandbox
* `provider` (string): Provider hosting the sandbox (e.g., ‚Äòe2b‚Äô, ‚Äòmodal‚Äô, ‚Äòvercel‚Äô)
* `filesystem` (SandboxFileSystem): File system operations interface
* Core methods: `runCode()`, `runCommand()`, `getInfo()`, `getUrl()`, `destroy()`
* Advanced features: `terminal`, `run`, `server`, `watcher`, `env`, `file`, and more
* See [Sandbox API Reference](./Sandbox.md) for complete interface documentation

**CreateSandboxOptions interface:**

```
{
  timeout?: number;               // Execution timeout in milliseconds
  templateId?: string;            // Provider template/image identifier
  metadata?: Record<string, any>; // Custom metadata
  envs?: Record<string, string>;  // Environment variables
  name?: string;                  // Named sandbox identifier
  namespace?: string;             // Named sandbox namespace
}
```

**Examples:**

```
import { compute } from 'computesdk';

// Basic sandbox creation (auto-detects provider)
const sandbox = await compute.sandbox.create();
console.log(sandbox.sandboxId);  // "sb_abc123..."
console.log(sandbox.provider);   // "e2b"

// With timeout (30 minutes)
const sandbox = await compute.sandbox.create({
  timeout: 30 * 60 * 1000
});

// With environment variables
const sandbox = await compute.sandbox.create({
  envs: {
    API_KEY: 'your-api-key',
    NODE_ENV: 'production',
    DATABASE_URL: 'postgresql://...'
  }
});

// With provider template/image
const sandbox = await compute.sandbox.create({
  templateId: 'your-template-id'
});

// With custom metadata
const sandbox = await compute.sandbox.create({
  metadata: {
    userId: 'user-123',
    projectId: 'proj-456',
    environment: 'staging'
  }
});

// With multiple options combined
const sandbox = await compute.sandbox.create({
  timeout: 60 * 60 * 1000,  // 1 hour
  templateId: 'your-template-id',
  envs: {
    NODE_ENV: 'production',
    DEBUG: 'true'
  },
  metadata: {
    owner: 'team-backend',
    purpose: 'integration-tests'
  }
});

// Error handling - missing configuration
try {
  const sandbox = await compute.sandbox.create();
} catch (error) {
  console.error('Failed to create sandbox:', error.message);
  // Error: No ComputeSDK configuration found.
  // Set COMPUTESDK_API_KEY and provider credentials
}
```

**Notes:**

* Provider is auto-detected from environment variables when `COMPUTESDK_API_KEY` is set with provider-specific credentials
* Each call creates a new sandbox instance with a unique `sandboxId`
* The `timeout` option sets maximum sandbox lifetime; sandboxes auto-terminate after this period
* The `templateId` parameter is provider-specific (refers to templates, images, or runtime environments)
* Environment variables set via `envs` are available to all commands and code executed in the sandbox
* Throws an error if ComputeSDK is not configured (missing API key or provider credentials)



***

## `destroy(sandboxId)`

[Section titled ‚Äúdestroy(sandboxId)‚Äù](#destroysandboxid)

Destroy a sandbox and clean up all associated resources.

**Parameters:**

* `sandboxId` (string, required): Unique identifier of the sandbox to destroy

**Returns:** `Promise<void>` - Resolves when sandbox is successfully destroyed

> **‚ö†Ô∏è CAUTION:** Destroying a sandbox is a permanent operation. All data, files, and running processes in the sandbox will be irreversibly deleted.

**Examples:**

```
import { compute } from 'computesdk';

// Basic cleanup after use
const sandbox = await compute.sandbox.create();
// ... use sandbox ...
await compute.sandbox.destroy(sandbox.sandboxId);

// Destroy sandbox by stored ID
const sandboxId = 'sb_abc123...';
await compute.sandbox.destroy(sandboxId);

// Batch cleanup - destroy multiple sandboxes
const sandboxIds = ['sb_123...', 'sb_456...', 'sb_789...'];
await Promise.all(sandboxIds.map(id => compute.sandbox.destroy(id)));

// With error handling
try {
  await compute.sandbox.destroy(sandbox.sandboxId);
  console.log('Sandbox destroyed successfully');
} catch (error) {
  console.error('Failed to destroy sandbox:', error.message);
}

// Best practice: ensure cleanup with finally block
let sandbox;
try {
  sandbox = await compute.sandbox.create();
  await sandbox.runCode('console.log("Hello")');
} finally {
  if (sandbox) {
    await compute.sandbox.destroy(sandbox.sandboxId);
  }
}
```

**Notes:**

* Destroying a sandbox terminates all running processes and releases all allocated resources
* This operation is idempotent - calling destroy on an already-destroyed sandbox succeeds without error
* Best practice: Use `finally` blocks or cleanup handlers to ensure sandboxes are destroyed even if errors occur
* All sandbox data and files are permanently lost after destruction



***

## `getById(sandboxId)`

[Section titled ‚ÄúgetById(sandboxId)‚Äù](#getbyidsandboxid)

Retrieve an existing sandbox instance by its unique identifier.

**Parameters:**

* `sandboxId` (string, required): Unique identifier of the sandbox to retrieve

**Returns:** `Promise<Sandbox | null>` - Sandbox instance if found, or `null` if the sandbox doesn‚Äôt exist

**Sandbox instance properties:**

* `sandboxId` (string): Unique identifier for the sandbox
* `provider` (string): Provider hosting the sandbox
* `filesystem` (SandboxFileSystem): File system operations interface
* Core methods: `runCode()`, `runCommand()`, `getInfo()`, `getUrl()`, `destroy()`
* Advanced features: `terminal`, `run`, `server`, `watcher`, `env`, `file`, and more
* See [Sandbox API Reference](./Sandbox.md) for complete interface documentation

**Examples:**

```
import { compute } from 'computesdk';

// Reconnect to existing sandbox by ID
const sandboxId = 'sb_abc123...';
const sandbox = await compute.sandbox.getById(sandboxId);

if (sandbox) {
  const result = await sandbox.runCode('console.log("Reconnected!")');
  console.log(result.output);  // "Reconnected!"
}

// Store ID and reconnect later
// Step 1: Create and store ID
const newSandbox = await compute.sandbox.create();
const storedId = newSandbox.sandboxId;
// Store storedId in database, config file, etc.

// Step 2: Later, retrieve using stored ID
const retrievedSandbox = await compute.sandbox.getById(storedId);
if (retrievedSandbox) {
  await retrievedSandbox.runCommand('npm install');
}

// Check if sandbox exists before using
const sandbox = await compute.sandbox.getById(sandboxId);

if (sandbox === null) {
  console.log('Sandbox not found - creating new one');
  const newSandbox = await compute.sandbox.create();
} else {
  console.log('Sandbox found - using existing one');
  await sandbox.runCode('print("Still active!")');
}

// Graceful handling of missing sandbox
const sandboxId = 'sb_might_not_exist...';
const sandbox = await compute.sandbox.getById(sandboxId);

if (sandbox) {
  // Sandbox exists - use it
  await sandbox.runCommand('npm test');
  console.log('Tests completed on existing sandbox');
} else {
  // Sandbox not found - handle accordingly
  console.log('Sandbox no longer exists');
}
```

**Notes:**

* Returns `null` for non-existent or destroyed sandboxes (does not throw errors)
* Retrieved sandboxes have full functionality identical to newly created sandboxes
* Useful for reconnecting to long-lived sandboxes or implementing persistent sandbox patterns
* Sandbox IDs can be stored and used to reconnect later across application restarts



***

## `list()`

[Section titled ‚Äúlist()‚Äù](#list)

**‚ÑπÔ∏è NOTE:** The `list()` method is currently not supported when using the gateway API (`import { compute } from 'computesdk'`). This functionality is actively being developed and will be available in a future release.

WIP: to retrieve a list of your active sandboxes from your provider, using `compute.sandbox.list()`

**Alternative Approach:** Until `list()` is available, you can **Track sandbox IDs locally**: Store sandbox IDs in your application (database, config, memory) and retrieve them using `getById()`



***

## `findOrCreate(options)`

[Section titled ‚ÄúfindOrCreate(options)‚Äù](#findorcreateoptions)

Find an existing named sandbox or create a new one if it doesn‚Äôt exist. Named sandboxes provide persistent, reusable sandbox instances identified by `(namespace, name)` pairs.

**Parameters:**

* `options` (FindOrCreateSandboxOptions, required): Configuration for finding or creating the sandbox

  * `name` (string, required): Unique identifier for the sandbox within its namespace
  * `namespace` (string, optional): Isolation scope for the sandbox (defaults to ‚Äúdefault‚Äù)
  * `timeout` (number, optional): Sandbox execution timeout in milliseconds (only used when creating)
  * `templateId` (string, optional): Provider-specific template identifier (only used when creating)
  * `metadata` (Record\<string, any>, optional): Custom metadata (only used when creating)
  * `envs` (Record\<string, string>, optional): Environment variables (only used when creating)

**Returns:** `Promise<Sandbox>` - Existing sandbox if found by name, or newly created sandbox if not found

**FindOrCreateSandboxOptions interface:**

```
{
  name: string;                   // Required: Unique sandbox identifier
  namespace?: string;             // Optional: Defaults to "default"
  timeout?: number;               // Used only when creating
  templateId?: string;            // Used only when creating
  metadata?: Record<string, any>; // Used only when creating
  envs?: Record<string, string>;  // Used only when creating
}
```

**Examples:**

```
import { compute } from 'computesdk';

// Basic usage - find or create by name
const sandbox = await compute.sandbox.findOrCreate({
  name: 'my-dev-sandbox'
});
console.log(sandbox.sandboxId);  // Consistent ID for "my-dev-sandbox"

// With custom namespace for isolation
const sandbox = await compute.sandbox.findOrCreate({
  name: 'build-env',
  namespace: 'project-123'
});
// Creates/finds sandbox uniquely identified by (project-123, build-env)

// With creation options (used only if sandbox doesn't exist)
const sandbox = await compute.sandbox.findOrCreate({
  name: 'ci-runner',
  namespace: 'github-actions',
  timeout: 60 * 60 * 1000,  // 1 hour (only applied to new sandboxes)
  envs: {
    NODE_ENV: 'test',
    CI: 'true'
  },
  metadata: {
    workflow: 'test-suite',
    branch: 'main'
  }
});


// Multi-tenant isolation with namespaces
const tenant1Sandbox = await compute.sandbox.findOrCreate({
  name: 'app-instance',
  namespace: 'tenant-abc'  // Isolated to tenant-abc
});

const tenant2Sandbox = await compute.sandbox.findOrCreate({
  name: 'app-instance',
  namespace: 'tenant-xyz'  // Isolated to tenant-xyz
});
// Both use same name but are separate sandboxes due to different namespaces
```

**Notes:**

* **Idempotent operation**: Safe to call multiple times - always returns the same sandbox for a given `(namespace, name)` pair
* The `namespace` defaults to `"default"` if not specified
* Creation options (`timeout`, `templateId`, `metadata`, `envs`) are only applied when creating a new sandbox
* If the sandbox already exists, creation options are ignored and the existing sandbox is returned as-is
* Named sandboxes persist until explicitly destroyed with `destroy(sandboxId)`
* Useful for implementing persistent workspaces, shared environments, or CI/CD build caches
* The returned Sandbox instance includes `name` and `namespace` in its metadata



***

## `find(options)`

[Section titled ‚Äúfind(options)‚Äù](#findoptions)

Find an existing named sandbox without creating a new one if it doesn‚Äôt exist.

**Parameters:**

* `options` (FindSandboxOptions, required): Configuration for finding the sandbox

  * `name` (string, required): Unique identifier for the sandbox within its namespace
  * `namespace` (string, optional): Isolation scope for the sandbox (defaults to ‚Äúdefault‚Äù)

**Returns:** `Promise<Sandbox | null>` - Existing sandbox if found by name, or `null` if not found

**FindSandboxOptions interface:**

```
{
  name: string;       // Required: Unique sandbox identifier
  namespace?: string; // Optional: Defaults to "default"
}
```

**Examples:**

```
import { compute } from 'computesdk';

// Basic usage - find by name
const sandbox = await compute.sandbox.find({
  name: 'my-dev-sandbox'
});

if (sandbox) {
  console.log('Found existing sandbox:', sandbox.sandboxId);
  await sandbox.runCommand('ls -la');
} else {
  console.log('Sandbox not found');
}

// Find with custom namespace
const sandbox = await compute.sandbox.find({
  name: 'build-env',
  namespace: 'project-123'
});

// Cleanup check - find before destroying
const toCleanup = await compute.sandbox.find({
  name: 'temp-environment',
  namespace: 'staging'
});

if (toCleanup) {
  await compute.sandbox.destroy(toCleanup.sandboxId);
  console.log('Cleaned up temporary environment');
}
```

**Notes:**

* Returns `null` if no sandbox exists with the given `(namespace, name)` pair (does not throw errors)
* The `namespace` defaults to `"default"` if not specified
* Does not create a new sandbox - read-only lookup operation
* Use this when you want to check for existence without automatically creating
* More explicit than `findOrCreate()` when you need different handling for found vs not-found cases



***

## `extendTimeout(sandboxId, options?)`

[Section titled ‚ÄúextendTimeout(sandboxId, options?)‚Äù](#extendtimeoutsandboxid-options)

Extend the timeout/TTL (time-to-live) for an existing sandbox to prevent automatic shutdown.

**Parameters:**

* `sandboxId` (string, required): Unique identifier of the sandbox to extend
* `options` (ExtendTimeoutOptions, optional): Extension configuration
  * `duration` (number, optional): Extension duration in milliseconds (default: 900000 = 15 minutes)

**Returns:** `Promise<void>` - Resolves when timeout is successfully extended

**ExtendTimeoutOptions interface:**

```
{
  duration?: number;  // Extension duration in milliseconds (default: 15 minutes)
}
```

**Examples:**

```
import { compute } from 'computesdk';

// Basic timeout extension (default: 15 minutes)
const sandbox = await compute.sandbox.create();
await compute.sandbox.extendTimeout(sandbox.sandboxId);
console.log('Sandbox lifetime extended by 15 minutes');

// Custom extension duration (1 hour)
await compute.sandbox.extendTimeout(sandbox.sandboxId, {
  duration: 60 * 60 * 1000  // 3600000 ms = 1 hour
});


// Long-running task with periodic extensions
async function longRunningBuild(sandbox: Sandbox) {
  const extendEvery = 20 * 60 * 1000;  // 20 minutes
  const extendBy = 30 * 60 * 1000;      // 30 minutes

  const keepAlive = setInterval(async () => {
    await compute.sandbox.extendTimeout(sandbox.sandboxId, {
      duration: extendBy
    });
  }, extendEvery);

  try {
    await sandbox.runCommand('npm run build:production');
    console.log('Build completed successfully');
  } finally {
    clearInterval(keepAlive);
  }
}
```

**Notes:**

* Default extension duration is 15 minutes (900000 milliseconds)
* Extends the maximum lifetime of the sandbox from the current time
* Does not restart or reset the sandbox - only prevents automatic shutdown
* Can be called multiple times to keep extending as needed
* Useful for long-running operations like large builds, extensive test suites, or data processing
* The sandbox will still shut down when explicitly destroyed with `destroy()`

# compute.templates

Coming Soon

# Sandbox (interface)

## Overview

[Section titled ‚ÄúOverview‚Äù](#overview)

Methods available for interacting with a compute sandbox.



***

## `runCommand(command, options?)`

[Section titled ‚ÄúrunCommand(command, options?)‚Äù](#runcommandcommand-options)

Execute shell commands in the sandbox with full control over execution environment.

**Parameters:**

* `command` (string, required): The shell command to execute as a single string

* `options` (RunCommandOptions, optional): Execution options

  * `cwd` (string, optional): Working directory for command execution
  * `env` (Record\<string, string>, optional): Environment variables to set
  * `timeout` (number, optional): Command timeout in milliseconds
  * `background` (boolean, optional): Run command in background without waiting for completion

**Returns:** `Promise<CommandResult>` - Command execution result with output streams, exit code, and duration

**CommandResult interface:**

* `stdout` (string): Standard output from the command
* `stderr` (string): Standard error output from the command
* `exitCode` (number): Exit code (0 for success, non-zero for errors)
* `durationMs` (number): Command execution duration in milliseconds

**Examples:**

```
// Simple command execution
const result = await sandbox.runCommand('ls -la');
console.log(result.stdout);      // Directory listing
console.log(result.exitCode);    // 0
console.log(result.durationMs);  // 45

// Command with working directory
const result = await sandbox.runCommand('npm install', {
  cwd: '/app'
});
console.log(result.stdout);

// Command with environment variables
const result = await sandbox.runCommand('node server.js', {
  env: { 
    NODE_ENV: 'production',
    PORT: '3000'
  }
});

// Background command execution
const result = await sandbox.runCommand('npm run dev', {
  background: true
});
// Command runs in background, result returns immediately

// Combined options
const result = await sandbox.runCommand('python script.py', {
  cwd: '/app/scripts',
  env: { DEBUG: 'true' },
  timeout: 30000
});

// Error handling with exit codes
const result = await sandbox.runCommand('grep pattern file.txt');
if (result.exitCode !== 0) {
  console.error('Command failed:', result.stderr);
} else {
  console.log('Match found:', result.stdout);
}

// Multi-command execution (use shell operators)
const result = await sandbox.runCommand('cd /app && npm install && npm test');

// Command with shell pipes and redirects
const result = await sandbox.runCommand('cat data.txt | grep "error" | wc -l');
```

**Notes:**

* Commands are executed as a single string, not as separate command + arguments arrays
* Use shell operators (`&&`, `||`, `|`, etc.) within the command string for complex operations
* Non-zero exit codes indicate command failure but do not throw errors - check `exitCode` in the result
* Background commands return immediately with `exitCode: 0` without waiting for completion
* The command runs in a shell context, so all shell features (pipes, redirects, etc.) are available
* Available on all sandbox instances regardless of provider



***

## `runCode(code, language?)`

[Section titled ‚ÄúrunCode(code, language?)‚Äù](#runcodecode-language)

Execute code in the sandbox with automatic language detection or explicit runtime.

**Parameters:**

* `code` (string, required): The code to execute
* `language` (‚Äònode‚Äô | ‚Äòpython‚Äô | ‚Äòdeno‚Äô | ‚Äòbun‚Äô, optional): Runtime environment for execution. Auto-detects if not specified.

**Returns:** `Promise<CodeResult>` - Execution result with output, exit code, and detected language

**CodeResult interface:**

* `output` (string): Combined output from code execution
* `exitCode` (number): Exit code (0 for success, non-zero for errors)
* `language` (string): Detected or specified programming language

**Examples:**

```
// Auto-detect language (Python)
const result = await sandbox.runCode('print("Hello from Python")');
console.log(result.output);    // "Hello from Python\n"
console.log(result.exitCode);  // 0
console.log(result.language);  // "python"

// Auto-detect language (Node.js)
const result = await sandbox.runCode('console.log("Hello from Node.js")');
console.log(result.output);    // "Hello from Node.js\n"
console.log(result.language);  // "node"

// Explicit runtime
const result = await sandbox.runCode('console.log("Hello")', 'node');

// Multi-line Python code
const pythonResult = await sandbox.runCode(`
def greet(name):
    return f"Hello, {name}!"
    
print(greet("World"))
`, 'python');
console.log(pythonResult.output); // "Hello, World!\n"
```

**Notes:**

* Supports automatic language detection for Python and Node.js code
* Available on all sandbox instances regardless of provider
* Returns structured output with exit codes for error handling



***

## `getInfo()`

[Section titled ‚ÄúgetInfo()‚Äù](#getinfo)

Get information about the sandbox including status, runtime, provider, and metadata.

**Parameters:** None

**Returns:** `Promise<SandboxInfo>` - Sandbox information including status, runtime, and configuration

**SandboxInfo interface:**

* `id` (string): Unique identifier for the sandbox
* `provider` (string): Provider hosting the sandbox (e.g., ‚Äòe2b‚Äô, ‚Äòmodal‚Äô, ‚Äòdocker‚Äô)
* `runtime` (Runtime): Runtime environment (‚Äònode‚Äô | ‚Äòpython‚Äô | ‚Äòdeno‚Äô | ‚Äòbun‚Äô)
* `status` (string): Current sandbox status (‚Äòrunning‚Äô | ‚Äòstopped‚Äô | ‚Äòerror‚Äô)
* `createdAt` (Date): Timestamp when the sandbox was created
* `timeout` (number): Execution timeout in milliseconds
* `metadata` (Record\<string, any>, optional): Additional provider-specific metadata

**Examples:**

```
// Basic usage - inspect sandbox info
const info = await sandbox.getInfo();
console.log(info.id);         // "sb_abc123..."
console.log(info.provider);   // "e2b"
console.log(info.runtime);    // "python"
console.log(info.status);     // "running"

// Check sandbox status
const info = await sandbox.getInfo();
if (info.status === 'running') {
  console.log('Sandbox is active');
  await sandbox.runCode('print("Hello")');
} else {
  console.log('Sandbox is not available');
}

// Access provider and runtime info
const info = await sandbox.getInfo();
console.log(`Running on ${info.provider} with ${info.runtime} runtime`);
console.log(`Created: ${info.createdAt.toISOString()}`);
console.log(`Timeout: ${info.timeout}ms`);

// Full info inspection for debugging
const info = await sandbox.getInfo();
console.log('Sandbox Information:');
console.log(`  ID: ${info.id}`);
console.log(`  Provider: ${info.provider}`);
console.log(`  Runtime: ${info.runtime}`);
console.log(`  Status: ${info.status}`);
console.log(`  Created: ${info.createdAt}`);
console.log(`  Timeout: ${info.timeout}ms`);
if (info.metadata) {
  console.log(`  Metadata:`, info.metadata);
}
```

**Notes:**

* Returns information about the sandbox‚Äôs current state and configuration
* Gateway implementation returns locally cached information without making network calls
* The `metadata` field contains any custom metadata set during sandbox creation
* Available on all sandbox instances regardless of provider



***

## `getUrl(options)`

[Section titled ‚ÄúgetUrl(options)‚Äù](#geturloptions)

Get a publicly accessible URL for accessing services running on a specific port in the sandbox.

**Parameters:**

* `options` (object, required): URL configuration options

  * `port` (number, required): Port number where the service is running in the sandbox
  * `protocol` (string, optional): Protocol to use (‚Äòhttp‚Äô | ‚Äòhttps‚Äô). Defaults to ‚Äòhttps‚Äô

**Returns:** `Promise<string>` - Publicly accessible URL for the specified port

**Examples:**

```
// Access web server on port 3000
const url = await sandbox.getUrl({ port: 3000 });
console.log(url);  // "https://sandbox-123-3000.preview.computesdk.com"

// Use URL to make HTTP request
const url = await sandbox.getUrl({ port: 8080 });
const response = await fetch(url);
console.log(await response.text());

// Specify HTTP protocol
const url = await sandbox.getUrl({ 
  port: 5000, 
  protocol: 'http' 
});
console.log(url);  // "http://sandbox-123-5000.preview.computesdk.com"

// Multiple services on different ports
const apiUrl = await sandbox.getUrl({ port: 3000 });
const wsUrl = await sandbox.getUrl({ port: 8080 });
console.log('API:', apiUrl);
console.log('WebSocket:', wsUrl);

// Start server and get URL
await sandbox.runCommand('npm start', { background: true });
await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for server
const url = await sandbox.getUrl({ port: 3000 });
console.log(`Server running at: ${url}`);

// Error case - accessing URL before service is ready
const url = await sandbox.getUrl({ port: 3000 });
try {
  const response = await fetch(url);
  console.log('Server is ready:', response.status);
} catch (error) {
  console.error('Service not running on port 3000 yet');
  // Wait and retry, or start the service first
}
```

**Notes:**

* Returns a publicly accessible URL that routes to the specified port in your sandbox
* URL construction is instantaneous (no network calls) - the URL is available immediately
* The service must be running on the specified port for the URL to be accessible



***

## `sandbox.filesystem`

[Section titled ‚Äúsandbox.filesystem‚Äù](#sandboxfilesystem)

ComputeSDK provides filesystem operations for managing files and directories within sandboxes. All filesystem operations are accessed through the `sandbox.filesystem` object.

### `filesystem.readFile(path)`

[Section titled ‚Äúfilesystem.readFile(path)‚Äù](#filesystemreadfilepath)

Read the contents of a file from the sandbox filesystem.

**Parameters:**

* `path` (string, required): Absolute path to the file to read within the sandbox

**Returns:** `Promise<string>` - File contents as UTF-8 encoded string

**Examples:**

```
// Basic file reading
const content = await sandbox.filesystem.readFile('/app/config.txt');
console.log(content);  // "port=3000\nhost=localhost"

// Read a JSON file
const jsonContent = await sandbox.filesystem.readFile('/app/package.json');
const packageData = JSON.parse(jsonContent);
console.log(packageData.name);     // "my-app"
console.log(packageData.version);  // "1.0.0"

// Read configuration files
const envContent = await sandbox.filesystem.readFile('/app/.env');
console.log(envContent);  // "API_KEY=secret\nDEBUG=true"

// Error handling for non-existent files
try {
  const content = await sandbox.filesystem.readFile('/nonexistent.txt');
} catch (error) {
  console.error('Failed to read file:', error.message);
  // "Failed to read file: File not found: /nonexistent.txt"
}

// Check existence before reading
const filePath = '/app/optional-config.json';
if (await sandbox.filesystem.exists(filePath)) {
  const content = await sandbox.filesystem.readFile(filePath);
  console.log('Config loaded:', content);
} else {
  console.log('Config file not found, using defaults');
}

// Read after writing
await sandbox.filesystem.writeFile('/app/output.txt', 'Hello, World!');
const content = await sandbox.filesystem.readFile('/app/output.txt');
console.log(content);  // "Hello, World!"

// Read code files
const scriptContent = await sandbox.filesystem.readFile('/app/server.js');
console.log(scriptContent);  // "const express = require('express');\n..."

// Read markdown files
const readme = await sandbox.filesystem.readFile('/app/README.md');
console.log(readme);  // "# My Project\n\nDescription..."
```

**Notes:**

* Always returns UTF-8 encoded strings
* Throws an error if the file does not exist
* Requires absolute paths (paths should start with `/`)
* No encoding options available - always returns UTF-8



***

### `filesystem.writeFile(path, content)`

[Section titled ‚Äúfilesystem.writeFile(path, content)‚Äù](#filesystemwritefilepath-content)

Write content to a file in the sandbox filesystem, creating the file if it doesn‚Äôt exist.

**Parameters:**

* `path` (string, required): Absolute path where the file should be written
* `content` (string, required): Content to write to the file as UTF-8 text

**Returns:** `Promise<void>` - Resolves when the file is successfully written

**Examples:**

```
// Basic file writing
await sandbox.filesystem.writeFile('/app/config.txt', 'port=3000\nhost=localhost');
console.log('File written successfully');

// Write JSON data
const data = { name: 'my-app', version: '1.0.0' };
await sandbox.filesystem.writeFile('/app/package.json', JSON.stringify(data, null, 2));

// Write configuration files
const envContent = 'API_KEY=secret\nDEBUG=true\nPORT=3000';
await sandbox.filesystem.writeFile('/app/.env', envContent);

// Overwrite existing files
await sandbox.filesystem.writeFile('/app/log.txt', 'First entry');
await sandbox.filesystem.writeFile('/app/log.txt', 'Second entry');
const content = await sandbox.filesystem.readFile('/app/log.txt');
console.log(content);  // "Second entry" (first entry was overwritten)

// Error handling
try {
  await sandbox.filesystem.writeFile('/app/data.json', JSON.stringify({ key: 'value' }));
  console.log('File created successfully');
} catch (error) {
  console.error('Failed to write file:', error.message);
}

// Write multiline content with template literals
const script = `#!/bin/bash
echo "Starting application..."
npm install
npm start
`;
await sandbox.filesystem.writeFile('/app/start.sh', script);

// Write then read to verify
const newContent = 'Hello, World!';
await sandbox.filesystem.writeFile('/app/greeting.txt', newContent);
const readBack = await sandbox.filesystem.readFile('/app/greeting.txt');
console.log(readBack === newContent);  // true
```

**Notes:**

* Always writes UTF-8 encoded text
* Creates the file if it doesn‚Äôt exist
* Overwrites existing files completely (previous content is lost)
* Requires absolute paths (paths should start with `/`)
* No encoding options available - always UTF-8



***

### `filesystem.mkdir(path)`

[Section titled ‚Äúfilesystem.mkdir(path)‚Äù](#filesystemmkdirpath)

Create a directory in the sandbox filesystem, automatically creating parent directories as needed.

**Parameters:**

* `path` (string, required): Absolute path of the directory to create

**Returns:** `Promise<void>` - Resolves when the directory is successfully created

**Examples:**

```
// Basic directory creation
await sandbox.filesystem.mkdir('/app/data');
console.log('Directory created');

// Multiple directories for project structure
await sandbox.filesystem.mkdir('/app/src');
await sandbox.filesystem.mkdir('/app/tests');
await sandbox.filesystem.mkdir('/app/dist');

// Directory already exists - succeeds silently
await sandbox.filesystem.mkdir('/app/data');
await sandbox.filesystem.mkdir('/app/data'); // No error thrown
console.log('Both calls succeeded');

// Error handling
try {
  await sandbox.filesystem.mkdir('/app/project/data');
  console.log('Directory created successfully');
} catch (error) {
  console.error('Failed to create directory:', error.message);
}
```

**Notes:**

* Automatically creates parent directories as needed
* Does not throw an error if the directory already exists
* Requires absolute paths (paths should start with `/`)
* Throws errors only on actual failures (permissions, invalid paths, disk space issues)



***

### `filesystem.readdir(path)`

[Section titled ‚Äúfilesystem.readdir(path)‚Äù](#filesystemreaddirpath)

List the contents of a directory in the sandbox filesystem.

**Parameters:**

* `path` (string, required): Absolute path to the directory to list

**Returns:** `Promise<FileEntry[]>` - Array of entries in the directory

**FileEntry interface:**

* `name` (string): Name of the file or directory
* `type` (‚Äòfile‚Äô | ‚Äòdirectory‚Äô): Type of the entry
* `size` (number, optional): Size in bytes (for files)
* `modified` (Date, optional): Last modification timestamp

**Examples:**

```
// Basic directory listing
const entries = await sandbox.filesystem.readdir('/app');
console.log(entries);
// [
//   { name: 'config.json', type: 'file', size: 245 },
//   { name: 'src', type: 'directory' },
//   { name: 'package.json', type: 'file', size: 512 }
// ]

// List and display all entries
const entries = await sandbox.filesystem.readdir('/app');
entries.forEach(entry => {
  console.log(`${entry.type === 'directory' ? 'üìÅ' : 'üìÑ'} ${entry.name}`);
});
// üìÑ config.json
// üìÅ src
// üìÑ package.json


// Find specific files by extension
const entries = await sandbox.filesystem.readdir('/app/src');
const jsFiles = entries.filter(e => 
  e.type === 'file' && e.name.endsWith('.js')
);
console.log('JavaScript files:', jsFiles.map(f => f.name));

// Count files and directories
const entries = await sandbox.filesystem.readdir('/app');
const fileCount = entries.filter(e => e.type === 'file').length;
const dirCount = entries.filter(e => e.type === 'directory').length;
console.log(`Found ${fileCount} files and ${dirCount} directories`);

// Check if directory is empty
const entries = await sandbox.filesystem.readdir('/app/temp');
if (entries.length === 0) {
  console.log('Directory is empty');
} else {
  console.log(`Directory contains ${entries.length} items`);
}

// Error handling for non-existent directories
try {
  const entries = await sandbox.filesystem.readdir('/nonexistent');
  console.log(entries);
} catch (error) {
  console.error('Failed to read directory:', error.message);
  // "Failed to read directory: Directory not found: /nonexistent"
}

// Check existence before reading
const dirPath = '/app/optional-data';
if (await sandbox.filesystem.exists(dirPath)) {
  const entries = await sandbox.filesystem.readdir(dirPath);
  console.log(`Found ${entries.length} entries in ${dirPath}`);
} else {
  console.log('Directory does not exist');
}
```

**Notes:**

* Returns an array of FileEntry objects with file/directory metadata
* Requires absolute paths (paths should start with `/`)
* Only lists direct children - does not recursively list subdirectories
* Throws an error if the directory does not exist
* The `size` and `modified` fields may not be available on all providers
* Empty directories return an empty array (not an error)



***

### `filesystem.exists(path)`

[Section titled ‚Äúfilesystem.exists(path)‚Äù](#filesystemexistspath)

Check if a file or directory exists at the specified path in the sandbox filesystem.

**Parameters:**

* `path` (string, required): Absolute path to the file or directory to check

**Returns:** `Promise<boolean>` - Returns `true` if the path exists (file or directory), `false` otherwise

**Examples:**

```
// Basic file existence check
const exists = await sandbox.filesystem.exists('/app/config.json');
console.log(exists);  // true

// Basic directory existence check
const dirExists = await sandbox.filesystem.exists('/app/src');
console.log(dirExists);  // true

// Check for non-existent path (returns false, doesn't throw error)
const missing = await sandbox.filesystem.exists('/app/nonexistent.txt');
console.log(missing);  // false

// Check before reading to avoid errors
const configPath = '/app/config.json';
if (await sandbox.filesystem.exists(configPath)) {
  const content = await sandbox.filesystem.readFile(configPath);
  console.log('Config loaded:', content);
} else {
  console.log('Config file not found, using defaults');
}

// Check before writing to avoid overwriting
const outputPath = '/app/output.txt';
if (await sandbox.filesystem.exists(outputPath)) {
  console.log('File already exists, skipping write');
} else {
  await sandbox.filesystem.writeFile(outputPath, 'New content');
  console.log('File created');
}

// Verify file creation
await sandbox.filesystem.writeFile('/app/data.json', '{}');
const created = await sandbox.filesystem.exists('/app/data.json');
console.log('File created successfully:', created);  // true

// Verify file deletion
await sandbox.filesystem.writeFile('/app/temp.txt', 'temporary');
await sandbox.filesystem.remove('/app/temp.txt');
const stillExists = await sandbox.filesystem.exists('/app/temp.txt');
console.log('File still exists:', stillExists);  // false

// Verify directory creation
await sandbox.filesystem.mkdir('/app/logs');
const dirCreated = await sandbox.filesystem.exists('/app/logs');
console.log('Directory created:', dirCreated);  // true


// Check multiple files at once
const requiredFiles = ['/app/package.json', '/app/src/index.js', '/app/README.md'];
const checks = await Promise.all(
  requiredFiles.map(path => sandbox.filesystem.exists(path))
);
const allExist = checks.every(exists => exists);
console.log('All required files present:', allExist);
```

**Notes:**

* Returns a boolean value - never throws errors (unlike `readFile` or `readdir`)
* Works for both files and directories - no distinction in the return value
* Requires absolute paths (paths should start with `/`)
* Returns `false` for non-existent paths, not an error
* Cannot distinguish between a file and directory from the return value alone
* Useful for defensive programming to prevent errors before operations



***

### `filesystem.remove(path)`

[Section titled ‚Äúfilesystem.remove(path)‚Äù](#filesystemremovepath)

Remove a file or directory from the sandbox filesystem. For directories, this recursively removes all contents.

**Parameters:**

* `path` (string, required): Absolute path to the file or directory to remove

**Returns:** `Promise<void>` - Resolves when the file or directory is successfully removed

**Examples:**

```
// Basic file removal
await sandbox.filesystem.writeFile('/app/temp.txt', 'temporary data');
await sandbox.filesystem.remove('/app/temp.txt');
console.log('File removed');

// Basic directory removal (recursive)
await sandbox.filesystem.mkdir('/app/old-data');
await sandbox.filesystem.writeFile('/app/old-data/file1.txt', 'data');
await sandbox.filesystem.writeFile('/app/old-data/file2.txt', 'data');
await sandbox.filesystem.remove('/app/old-data');
console.log('Directory and all contents removed');

// Remove file and verify deletion
await sandbox.filesystem.writeFile('/app/output.txt', 'content');
await sandbox.filesystem.remove('/app/output.txt');
const exists = await sandbox.filesystem.exists('/app/output.txt');
console.log('File still exists:', exists);  // false

// Remove directory with nested contents
await sandbox.filesystem.mkdir('/app/cache/images/thumbnails');
await sandbox.filesystem.writeFile('/app/cache/data.json', '{}');
await sandbox.filesystem.writeFile('/app/cache/images/photo.jpg', 'image data');
await sandbox.filesystem.remove('/app/cache');
console.log('Entire cache directory tree removed');

// Error handling for non-existent paths
try {
  await sandbox.filesystem.remove('/app/nonexistent.txt');
} catch (error) {
  console.error('Failed to remove:', error.message);
  // "Failed to remove: File not found: /app/nonexistent.txt"
}

// Safe removal with existence check
const filePath = '/app/optional-cache.json';
if (await sandbox.filesystem.exists(filePath)) {
  await sandbox.filesystem.remove(filePath);
  console.log('Cache file removed');
} else {
  console.log('No cache file to remove');
}
```

**Notes:**

* Works for both files and directories - no distinction needed
* **Recursive deletion for directories** - removes all contents and subdirectories (like `rm -rf`)
* Requires absolute paths (paths should start with `/`)
* Throws an error if the path does not exist
* **Deletion is permanent** - no recycle bin, trash, or undo capability
* **Use with caution** - destructive operation that cannot be reversed
* For directories, all nested files and subdirectories are removed automatically
* No confirmation prompt - removal happens immediately



***

## `sandbox.terminals`

[Section titled ‚Äúsandbox.terminals‚Äù](#sandboxterminals)

### `terminals.create(options?)`

[Section titled ‚Äúterminals.create(options?)‚Äù](#terminalscreateoptions)

Create a terminal session in the sandbox with support for two modes: **PTY mode** (interactive shell with real-time I/O over WebSocket) and **Exec mode** (command tracking with structured results).

**Parameters:**

* `options` (object, optional): Terminal creation options

  * `pty` (boolean, optional): Terminal mode. `true` = PTY (interactive shell), `false` = exec (command tracking). Default: `false`
  * `shell` (string, optional): Shell to use (e.g., ‚Äò/bin/bash‚Äô, ‚Äò/bin/zsh‚Äô). PTY mode only. Default: system default shell
  * `encoding` (‚Äòraw‚Äô | ‚Äòbase64‚Äô, optional): Output encoding. Default: `'raw'`

**Returns:** `Promise<TerminalInstance>` - Terminal instance with properties and methods based on the selected mode

**TerminalInstance properties:**

* `id` (string): Unique identifier for the terminal
* `status` (‚Äòrunning‚Äô | ‚Äòstopped‚Äô | ‚Äòactive‚Äô | ‚Äòready‚Äô): Current terminal status
* `channel` (string | null): WebSocket channel identifier (PTY mode only, null for exec mode)
* `pty` (boolean): Whether this is a PTY terminal (true) or exec terminal (false)
* `command` (TerminalCommand): Command execution namespace (exec mode only)

**TerminalInstance methods (PTY mode):**

* `write(input: string): void` - Send input to the terminal shell
* `resize(cols: number, rows: number): void` - Resize terminal window dimensions
* `on(event: string, handler: Function): void` - Register event handler (‚Äòoutput‚Äô, ‚Äòerror‚Äô, ‚Äòdestroyed‚Äô)
* `off(event: string, handler: Function): void` - Unregister event handler
* `destroy(): Promise<void>` - Destroy the terminal and clean up resources

**TerminalInstance methods (Exec mode):**

* `command.run(command: string, options?: { background?: boolean }): Promise<Command>` - Execute a command
* `command.list(): Promise<Command[]>` - List all commands executed in this terminal
* `command.retrieve(cmdId: string): Promise<Command>` - Retrieve specific command by ID
* `destroy(): Promise<void>` - Destroy the terminal and clean up resources

**TerminalInstance methods (Both modes):**

* `isRunning(): boolean` - Check if terminal is currently running

**Command object (returned by command.run()):**

* `id` (string): Unique command identifier
* `terminalId` (string): Parent terminal ID
* `command` (string): The executed command string
* `status` (‚Äòrunning‚Äô | ‚Äòcompleted‚Äô | ‚Äòfailed‚Äô): Current command status
* `stdout` (string): Standard output from the command
* `stderr` (string): Standard error output from the command
* `exitCode` (number | undefined): Exit code (undefined if still running)
* `durationMs` (number | undefined): Execution duration in milliseconds
* `startedAt` (string): ISO timestamp when command started
* `finishedAt` (string | undefined): ISO timestamp when command finished (undefined if still running)
* `wait(timeout?: number): Promise<Command>` - Wait for command to complete (timeout in seconds, 0 = no timeout)
* `refresh(): Promise<Command>` - Refresh command status from server

**Examples:**

```
// PTY mode - Interactive shell with real-time output
const pty = await sandbox.terminals.create({ 
  pty: true, 
  shell: '/bin/bash' 
});

// Handle output events
pty.on('output', (data) => {
  console.log('Output:', data);
});

pty.on('error', (error) => {
  console.error('Error:', error);
});

pty.on('destroyed', () => {
  console.log('Terminal destroyed');
});

// Send commands to shell
pty.write('ls -la\n');
pty.write('cd /app\n');
pty.write('npm install\n');

// Resize terminal
pty.resize(120, 40);

// Clean up
await pty.destroy();
```

```
// Exec mode - Command execution with tracking
const exec = await sandbox.terminals.create({ pty: false });

// Run command in foreground (waits for completion)
const cmd = await exec.command.run('npm test');
console.log('Exit code:', cmd.exitCode);       // 0
console.log('Output:', cmd.stdout);            // Test results
console.log('Duration:', cmd.durationMs);      // 1543
console.log('Status:', cmd.status);            // 'completed'

// Check for errors
if (cmd.exitCode !== 0) {
  console.error('Command failed:', cmd.stderr);
} else {
  console.log('Tests passed!');
}

await exec.destroy();
```

```
// Exec mode - Background execution with wait
const exec = await sandbox.terminals.create({ pty: false });

// Start long-running command in background
const cmd = await exec.command.run('npm install', { background: true });
console.log('Command started:', cmd.id);
console.log('Status:', cmd.status);  // 'running'

// Wait for command to complete (60 second timeout)
await cmd.wait(60);
console.log('Installation complete');
console.log('Exit code:', cmd.exitCode);
console.log('Output:', cmd.stdout);

// Or refresh status without waiting
await cmd.refresh();
console.log('Current status:', cmd.status);

await exec.destroy();
```

**Notes:**

* **PTY mode** provides an interactive shell with WebSocket streaming for real-time I/O - use for interactive sessions
* **Exec mode** tracks individual commands with structured results - use for automation and scripting
* PTY terminals require WebSocket connection for real-time communication
* Exec mode commands can run in foreground (blocking) or background (non-blocking with wait capability)
* Always call `destroy()` to clean up terminal resources when done
* Background commands return immediately with status ‚Äòrunning‚Äô - use `wait()` to block until completion
* The `write()` and `resize()` methods are only available for PTY terminals
* The `command` namespace is only available for exec terminals
* Terminal status ‚Äòactive‚Äô is normalized to ‚Äòrunning‚Äô internally



***

### `terminals.list()`

[Section titled ‚Äúterminals.list()‚Äù](#terminalslist)

List all active terminal sessions in the sandbox.

**Parameters:** None

**Returns:** `Promise<TerminalResponse[]>` - Array of terminal information objects

**TerminalResponse interface:**

* `id` (string): Terminal identifier
* `pty` (boolean): Whether this is a PTY terminal
* `status` (‚Äòrunning‚Äô | ‚Äòstopped‚Äô | ‚Äòactive‚Äô | ‚Äòready‚Äô): Terminal status
* `channel` (string | null): WebSocket channel (PTY mode only)

**Examples:**

```
// List all terminals
const terminals = await sandbox.terminals.list();
console.log(`Active terminals: ${terminals.length}`);

terminals.forEach(term => {
  console.log(`${term.id} - ${term.pty ? 'PTY' : 'Exec'} - ${term.status}`);
});
```

**Notes:**

* Returns information about all active terminals regardless of mode
* Does not return TerminalInstance objects - use `retrieve()` to get a specific terminal instance



***

### `terminals.retrieve(id)`

[Section titled ‚Äúterminals.retrieve(id)‚Äù](#terminalsretrieveid)

Retrieve information about a specific terminal by ID.

**Parameters:**

* `id` (string, required): The terminal identifier

**Returns:** `Promise<TerminalResponse>` - Terminal information object

**TerminalResponse interface:**

* `id` (string): Terminal identifier
* `pty` (boolean): Whether this is a PTY terminal
* `status` (‚Äòrunning‚Äô | ‚Äòstopped‚Äô | ‚Äòactive‚Äô | ‚Äòready‚Äô): Terminal status
* `channel` (string | null): WebSocket channel (PTY mode only)

**Examples:**

```
// Retrieve specific terminal
const terminal = await sandbox.terminals.retrieve('term-abc123');
console.log(`Terminal ${terminal.id}: ${terminal.status}`);

// Check terminal type
if (terminal.pty) {
  console.log('PTY terminal on channel:', terminal.channel);
} else {
  console.log('Exec terminal');
}
```

**Notes:**

* Returns terminal metadata, not a TerminalInstance object
* Throws an error if the terminal does not exist



***

### `terminals.destroy(id)`

[Section titled ‚Äúterminals.destroy(id)‚Äù](#terminalsdestroyid)

Destroy a terminal session and clean up all associated resources.

**Parameters:**

* `id` (string, required): The terminal identifier

**Returns:** `Promise<void>` - Resolves when the terminal is destroyed

**Examples:**

```
// Destroy a terminal by ID
await sandbox.terminals.destroy('term-abc123');
console.log('Terminal destroyed');

// Destroy all terminals
const terminals = await sandbox.terminals.list();
await Promise.all(
  terminals.map(term => sandbox.terminals.destroy(term.id))
);
console.log('All terminals destroyed');
```

**Notes:**

* Destroys the terminal and cleans up all resources including WebSocket connections
* Throws an error if the terminal does not exist
* Background commands may be terminated when the terminal is destroyed



***

## `sandbox.server`

[Section titled ‚Äúsandbox.server‚Äù](#sandboxserver)

Manage long-running server processes:

### `server.start(options)`

[Section titled ‚Äúserver.start(options)‚Äù](#serverstartoptions)

Start a managed server process in the sandbox with automatic process management and URL exposure.

**Parameters:**

* `options` (object, required): Server configuration

  * `slug` (string, required): Unique URL-safe identifier for the server
  * `command` (string, required): Command to start the server process
  * `path` (string, optional): Working directory for command execution
  * `env_file` (string, optional): Path to environment file to load

**Returns:** `Promise<ServerInfo>` - Server information including status, URL, and process details

**ServerInfo interface:**

* `slug` (string): Server identifier
* `command` (string): The command being executed
* `path` (string): Working directory path
* `original_path` (string, optional): Original path before resolution
* `env_file` (string, optional): Environment file path if specified
* `port` (number, optional): Detected port number
* `url` (string, optional): Public URL when server is ready
* `status` (‚Äòstarting‚Äô | ‚Äòrunning‚Äô | ‚Äòready‚Äô | ‚Äòfailed‚Äô | ‚Äòstopped‚Äô): Current server status
* `pid` (number, optional): Process ID when running
* `terminal_id` (string, optional): Associated terminal session ID
* `created_at` (string): ISO timestamp when server was created
* `updated_at` (string): ISO timestamp of last status update

**Examples:**

```
// Basic server start
const server = await sandbox.server.start({
  slug: 'api',
  command: 'npm start'
});
console.log(server.slug);     // "api"
console.log(server.status);   // "starting"
console.log(server.command);  // "npm start"

// Server with environment file
const server = await sandbox.server.start({
  slug: 'api',
  command: 'node server.js',
  env_file: '.env.production'
});
console.log(server.env_file); // ".env.production"

// Check server status after starting
const server = await sandbox.server.start({
  slug: 'api',
  command: 'npm start'
});
console.log('Initial status:', server.status);  // "starting"

// Error handling
try {
  const server = await sandbox.server.start({
    slug: 'test-server',
    command: 'invalid-command'
  });
} catch (error) {
  console.error('Failed to start server:', error.message);
}
```

**Notes:**

* The `slug` must be unique across all servers in the sandbox
* Server processes continue running until explicitly stopped with `server.stop(slug)`
* Available on all sandbox instances regardless of provider



***

### `server.list()`

[Section titled ‚Äúserver.list()‚Äù](#serverlist)

List all managed server processes running in the sandbox.

**Parameters:** None

**Returns:** `Promise<ServerInfo[]>` - Array of server information objects (see `server.start()` for `ServerInfo` interface details)

**Examples:**

```
// Basic usage - list all servers
const servers = await sandbox.server.list();
console.log(`Found ${servers.length} servers`);

// Empty array when no servers running
const servers = await sandbox.server.list();
if (servers.length === 0) {
  console.log('No servers are currently running');
}

// Display all server information
const servers = await sandbox.server.list();
servers.forEach(server => {
  console.log(`${server.slug}: ${server.status}`);
  console.log(`  Command: ${server.command}`);
  console.log(`  URL: ${server.url || 'not ready'}`);
});
```

**Notes:**

* Returns an empty array if no servers are currently running
* Use `server.retrieve(slug)` to get information about a specific server by its slug
* Available on all sandbox instances regardless of provider



***

### `server.retrieve(slug)`

[Section titled ‚Äúserver.retrieve(slug)‚Äù](#serverretrieveslug)

Retrieve information about a specific server by its slug identifier.

**Parameters:**

* `slug` (string, required): The unique server slug identifier

**Returns:** `Promise<ServerInfo>` - Server information object (see `server.start()` for `ServerInfo` interface details)

**Examples:**

```
// Basic retrieval - get server by slug
const server = await sandbox.server.retrieve('api');
console.log(server.status);  // "ready"
console.log(server.url);     // "https://..."

// Check if server is ready
const server = await sandbox.server.retrieve('api');
if (server.status === 'ready') {
  console.log('Server is ready at:', server.url);
} else {
  console.log('Server is still', server.status);
}

// Check server process information
const server = await sandbox.server.retrieve('api');
console.log('Process ID:', server.pid);
console.log('Port:', server.port);
console.log('Terminal:', server.terminal_id);

// Check server status before operations
const server = await sandbox.server.retrieve('backend');
if (server.status === 'failed') {
  console.log('Server failed, restarting...');
  await sandbox.server.restart('backend');
} else if (server.status === 'ready') {
  console.log('Server is healthy');
}
```

**Notes:**

* Returns the current state of the server - status may change immediately after retrieval
* Use `server.list()` first to check if a server exists before calling `retrieve()`
* Available on all sandbox instances regardless of provider



***

### `server.stop(slug)`

[Section titled ‚Äúserver.stop(slug)‚Äù](#serverstopslug)

Stop a running server process.

**Parameters:**

* `slug` (string, required): The unique server slug identifier

**Returns:** `Promise<void>` - Resolves when the server is successfully stopped

**Examples:**

```
// Basic stop - stop a server by slug
await sandbox.server.stop('api');
console.log('Server stopped');

// Stop before starting with new configuration
await sandbox.server.stop('api');
const newServer = await sandbox.server.start({
  slug: 'api',
  command: 'npm run prod',
  path: '/app'
});
console.log('Server started with new configuration');

// Check status before stopping
const server = await sandbox.server.retrieve('api');
if (server.status === 'running' || server.status === 'ready') {
  await sandbox.server.stop('api');
  console.log('Server stopped');
} else {
  console.log('Server is not running');
}
```

**Notes:**

* Stops a running server process
* Use `server.retrieve(slug)` to check server status before stopping
* Available on all sandbox instances regardless of provider



***

### `server.restart(slug)`

[Section titled ‚Äúserver.restart(slug)‚Äù](#serverrestartslug)

Restart a server process.

**Parameters:**

* `slug` (string, required): The unique server slug identifier

**Returns:** `Promise<ServerInfo>` - Server information object after restart (see `server.start()` for `ServerInfo` interface details)

**Examples:**

```
// Basic restart - restart a server by slug
const server = await sandbox.server.restart('api');
console.log(server.status);  // Server status after restart
console.log(server.url);     // Server URL

// Restart and check updated status
const server = await sandbox.server.restart('backend');
console.log('Server restarted');
console.log('New status:', server.status);
console.log('New PID:', server.pid);

// Restart multiple servers sequentially
const api = await sandbox.server.restart('api');
const frontend = await sandbox.server.restart('frontend');
const worker = await sandbox.server.restart('worker');
console.log('All servers restarted');

// Check status before restart
const server = await sandbox.server.retrieve('api');
console.log('Current status:', server.status);
const restarted = await sandbox.server.restart('api');
console.log('New status:', restarted.status);
```

**Notes:**

* Returns updated server information after restart
* Use the returned `ServerInfo` object to check the new status, PID, and other details
* Available on all sandbox instances regardless of provider



***

## `sandbox.env`

[Section titled ‚Äúsandbox.env‚Äù](#sandboxenv)

Manage `.env` files in the sandbox:

### `env.retrieve(file)`

[Section titled ‚Äúenv.retrieve(file)‚Äù](#envretrievefile)

Retrieve all environment variables from a `.env` file in the sandbox as a key-value object.

**Parameters:**

* `file` (string, required): Path to the .env file relative to sandbox root (e.g., ‚Äò.env‚Äô, ‚Äò.env.production‚Äô, ‚Äòconfig/.env‚Äô)

**Returns:** `Promise<Record<string, string>>` - Key-value map of all environment variables in the file

**Examples:**

```
// Basic retrieval
const vars = await sandbox.env.retrieve('.env');
console.log(vars);  // { API_KEY: 'secret', DEBUG: 'true', PORT: '3000' }

// Access specific variables
const vars = await sandbox.env.retrieve('.env');
console.log(vars.API_KEY);  // "secret"
console.log(vars.DEBUG);    // "true"

// Check if file exists before retrieving
const exists = await sandbox.env.exists('.env.local');
if (exists) {
  const vars = await sandbox.env.retrieve('.env.local');
  console.log('Local config loaded:', vars);
} else {
  console.log('No local config found, using defaults');
}
```

**Notes:**

* Returns all environment variables as string key-value pairs
* File paths are relative to the sandbox root directory
* All values are returned as strings - no automatic type conversion
* Use with `env.exists()` to check file presence before retrieval

### `env.update(file, variables)`

[Section titled ‚Äúenv.update(file, variables)‚Äù](#envupdatefile-variables)

Update or add environment variables in a `.env` file, merging with existing variables.

**Parameters:**

* `file` (string, required): Path to the .env file relative to sandbox root (e.g., ‚Äò.env‚Äô, ‚Äò.env.production‚Äô, ‚Äòconfig/.env‚Äô)
* `variables` (Record\<string, string>, required): Key-value pairs of environment variables to set or update

**Returns:** `Promise<string[]>` - Array of environment variable keys that were updated or added

**Examples:**

```
// Basic update
const keys = await sandbox.env.update('.env', {
  API_KEY: 'new-secret',
  DEBUG: 'true'
});
console.log(keys);  // ['API_KEY', 'DEBUG']

// Conditional update with existence check
const exists = await sandbox.env.exists('.env.local');
if (!exists) {
  await sandbox.env.update('.env.local', { DEBUG: 'true', LOG_LEVEL: 'verbose' });
  console.log('Created new local environment file');
} else {
  await sandbox.env.update('.env.local', { DEBUG: 'false' });
  console.log('Updated existing local environment');
}
```

**Notes:**

* Merges with existing variables - does not replace the entire file
* Existing variables not mentioned in the update are preserved
* Creates the file if it doesn‚Äôt exist
* All values must be strings - no automatic type conversion
* File paths are relative to the sandbox root directory
* Returns array of keys that were modified or added

### `env.remove(file, keys)`

[Section titled ‚Äúenv.remove(file, keys)‚Äù](#envremovefile-keys)

Remove specific environment variables from a `.env` file while preserving all other variables.

**Parameters:**

* `file` (string, required): Path to the .env file relative to sandbox root (e.g., ‚Äò.env‚Äô, ‚Äò.env.production‚Äô, ‚Äòconfig/.env‚Äô)
* `keys` (string\[], required): Array of environment variable keys to remove from the file

**Returns:** `Promise<string[]>` - Array of environment variable keys that were successfully removed

**Examples:**

```
// Basic removal
const removed = await sandbox.env.remove('.env', ['OLD_KEY', 'DEPRECATED']);
console.log(removed);  // ['OLD_KEY', 'DEPRECATED']

// Conditional removal with existence check
const exists = await sandbox.env.exists('.env.local');
if (exists) {
  const vars = await sandbox.env.retrieve('.env.local');
  if ('DEBUG' in vars) {
    await sandbox.env.remove('.env.local', ['DEBUG']);
    console.log('DEBUG variable removed from local environment');
  }
}
```

**Notes:**

* Only removes specified keys - all other variables in the file are preserved
* Returns array of keys that were successfully removed
* File paths are relative to the sandbox root directory
* Use with `env.retrieve()` to check which variables exist before removal

### `env.exists(file)`

[Section titled ‚Äúenv.exists(file)‚Äù](#envexistsfile)

Check if a `.env` file exists in the sandbox.

**Parameters:**

* `file` (string, required): Path to the .env file relative to sandbox root (e.g., ‚Äò.env‚Äô, ‚Äò.env.production‚Äô, ‚Äòconfig/.env‚Äô)

**Returns:** `Promise<boolean>` - Returns `true` if the file exists, `false` otherwise

**Examples:**

```
// Basic existence check
const exists = await sandbox.env.exists('.env');
console.log(exists);  // true or false

// Conditional operations - check before retrieve
const exists = await sandbox.env.exists('.env.local');
if (exists) {
  const vars = await sandbox.env.retrieve('.env.local');
  console.log('Local config loaded:', vars);
} else {
  console.log('No local config found, using defaults');
}

// Check before update - determine whether to create or update
const exists = await sandbox.env.exists('.env.production');
if (!exists) {
  await sandbox.env.update('.env.production', {
    NODE_ENV: 'production',
    DATABASE_URL: 'postgres://prod-server/db'
  });
  console.log('Production environment file created');
} else {
  console.log('Production environment file already exists');
}
```

**Notes:**

* Returns a boolean value - never throws errors (safe to call without try/catch)
* Returns `false` for non-existent files rather than throwing an error
* File paths are relative to the sandbox root directory



***

## `sandbox.file`

[Section titled ‚Äúsandbox.file‚Äù](#sandboxfile)

Resource-oriented file operations. Note that `sandbox.file` is distinct from `sandbox.filesystem`:

* **`sandbox.file`** - Resource-oriented API with create/retrieve/destroy naming
* **`sandbox.filesystem`** - Traditional filesystem API with readFile/writeFile/mkdir/readdir/exists/remove

### `file.create(path, content?)`

[Section titled ‚Äúfile.create(path, content?)‚Äù](#filecreatepath-content)

Create a new file with optional content.

**Parameters:**

* `path` (string, required): File path
* `content` (string, optional): File content

**Returns:** `Promise<FileInfo>` - File information object

**FileInfo interface:**

* `name` (string): File name
* `path` (string): Full file path
* `size` (number): File size in bytes
* `is_dir` (boolean): Whether this is a directory
* `modified_at` (string): ISO timestamp of last modification

**Examples:**

```
// Basic file creation with content
const file = await sandbox.file.create('/project/hello.txt', 'Hello, World!');
console.log(file.name);        // 'hello.txt'
console.log(file.size);        // 13
console.log(file.modified_at); // '2024-01-08T12:00:00Z'

// Create empty file (content is optional)
const emptyFile = await sandbox.file.create('/project/empty.txt');
console.log(emptyFile.size);   // 0

// Create JSON configuration file
const config = { api_url: 'https://api.example.com', timeout: 5000 };
const configFile = await sandbox.file.create(
  '/project/config.json', 
  JSON.stringify(config, null, 2)
);
console.log(configFile.name);  // 'config.json'

// Create file with multiline content using template literals
const script = await sandbox.file.create('/project/start.sh', `#!/bin/bash
echo "Starting application..."
npm install
npm start
`);
console.log(script.name);      // 'start.sh'

// Error handling for creation failures
try {
  const file = await sandbox.file.create('/invalid/path/file.txt', 'content');
  console.log('File created:', file.name);
} catch (error) {
  console.error('Failed to create file:', error.message);
}
```

**Notes:**

* Creates a new file or overwrites if the file already exists
* Content parameter is optional - omit it to create an empty file
* Always returns UTF-8 encoded text
* Available on all sandbox instances regardless of provider



***

### `file.list(path?)`

[Section titled ‚Äúfile.list(path?)‚Äù](#filelistpath)

List files at the specified path.

**Parameters:**

* `path` (string, optional, default: ‚Äô/‚Äô): Directory path to list

**Returns:** `Promise<FileInfo[]>` - Array of FileInfo objects

**Examples:**

```
// Basic directory listing with iteration
const files = await sandbox.file.list('/project');
files.forEach(file => {
  console.log(`${file.is_dir ? 'üìÅ' : 'üìÑ'} ${file.name} (${file.size} bytes)`);
});
// Output:
// üìÑ hello.txt (13 bytes)
// üìÅ src (4096 bytes)
// üìÑ package.json (512 bytes)

// List root directory (default parameter)
const rootFiles = await sandbox.file.list();  // Defaults to '/'
console.log(`Found ${rootFiles.length} items in root`);

// Alternative: explicitly specify root
const rootFiles2 = await sandbox.file.list('/');
console.log(rootFiles2.length);

// Separate files and directories
const items = await sandbox.file.list('/project');
const directories = items.filter(item => item.is_dir);
const regularFiles = items.filter(item => !item.is_dir);

console.log('Directories:', directories.map(d => d.name));
console.log('Files:', regularFiles.map(f => f.name));

// Check if directory is empty
const exists = await sandbox.file.exists('/project/temp');
if (exists) {
  const files = await sandbox.file.list('/project/temp');
  if (files.length === 0) {
    console.log('Directory is empty');
  } else {
    console.log(`Directory contains ${files.length} items`);
  }
} else {
  console.log('Directory does not exist');
}

// Defensive pattern: check existence before listing
const dirPath = '/project/optional-data';
if (await sandbox.file.exists(dirPath)) {
  const files = await sandbox.file.list(dirPath);
  console.log(`Found ${files.length} files`);
} else {
  console.log('Directory does not exist, skipping...');
}
```

**Notes:**

* Defaults to root directory (`'/'`) if path parameter is omitted
* Only lists direct children - does not recurse into subdirectories
* Returns FileInfo array with metadata (see `file.create()` for complete FileInfo interface details)
* Available on all sandbox instances regardless of provider



***

### `file.retrieve(path)`

[Section titled ‚Äúfile.retrieve(path)‚Äù](#fileretrievepath)

Retrieve file content.

**Parameters:**

* `path` (string, required): File path

**Returns:** `Promise<string>` - File content as string

**Examples:**

```
// Basic file retrieval
const content = await sandbox.file.retrieve('/project/hello.txt');
console.log(content); // 'Hello, World!'


// Read multiline file content (code, scripts, markdown)
const scriptContent = await sandbox.file.retrieve('/project/start.sh');
console.log(scriptContent);
// Output:
// #!/bin/bash
// echo "Starting application..."
// npm install
// npm start

// Defensive pattern: check existence before retrieving
const filePath = '/project/optional-config.json';
if (await sandbox.file.exists(filePath)) {
  const content = await sandbox.file.retrieve(filePath);
  const config = JSON.parse(content);
  console.log('Config loaded:', config);
} else {
  console.log('Config file not found, using defaults');
}
```

**Notes:**

* Always returns UTF-8 encoded text content as a string
* Returns content only - for file metadata (size, modified\_at, etc.), use `file.create()` or `file.list()`
* Does not include file metadata in the return value (unlike `file.create()` which returns FileInfo)
* Available on all sandbox instances regardless of provider



***

### `file.destroy(path)`

[Section titled ‚Äúfile.destroy(path)‚Äù](#filedestroypath)

Destroy (delete) a file or directory.

**Parameters:**

* `path` (string, required): File or directory path

**Returns:** `Promise<void>`

**Examples:**

```
// Basic file deletion
await sandbox.file.destroy('/project/hello.txt');
console.log('File deleted');

// Delete file and verify with exists()
await sandbox.file.create('/project/temp.txt', 'temporary data');
await sandbox.file.destroy('/project/temp.txt');

const exists = await sandbox.file.exists('/project/temp.txt');
console.log('File still exists:', exists);  // false

// Delete directory recursively (simple directory)
await sandbox.file.create('/project/data/file.txt', 'content');
await sandbox.file.destroy('/project/data');
console.log('Directory and contents deleted');

// Delete directory recursively (nested structure)
await sandbox.file.create('/project/cache/images/thumb.jpg', 'image');
await sandbox.file.create('/project/cache/data.json', '{}');
await sandbox.file.destroy('/project/cache');
console.log('Entire directory tree removed');

// Defensive pattern: check existence before destroying
const filePath = '/project/optional-file.txt';
if (await sandbox.file.exists(filePath)) {
  await sandbox.file.destroy(filePath);
  console.log('File deleted');
} else {
  console.log('File does not exist, nothing to delete');
}
```

**Notes:**

* For directories, recursively removes all contents and subdirectories (similar to `rm -rf`)
* Deletion is permanent - no recycle bin, trash, or undo capability - use with caution
* Available on all sandbox instances regardless of provider



***

### `file.batchWrite(files)`

[Section titled ‚Äúfile.batchWrite(files)‚Äù](#filebatchwritefiles)

Batch file operations (write or delete multiple files). Features deduplication (last operation wins per path), file locking (prevents race conditions), and deterministic ordering (alphabetical path sorting).

**Parameters:**

* `files` (Array, required): Array of file operations where each operation contains:

  * `path` (string, required): File path
  * `operation` (‚Äòwrite‚Äô | ‚Äòdelete‚Äô, required): Operation type
  * `content` (string, optional): File content (required for ‚Äòwrite‚Äô operations)

**Returns:** `Promise<BatchWriteResult[]>` - Array of results for each operation

**BatchWriteResult interface:**

* `path` (string): File path
* `success` (boolean): Whether the operation succeeded
* `error` (string, optional): Error message if operation failed
* `file` (FileInfo, optional): File info if operation succeeded

**Examples:**

```
// Batch write multiple files
const results = await sandbox.file.batchWrite([
  { path: '/project/a.txt', operation: 'write', content: 'A' },
  { path: '/project/b.txt', operation: 'write', content: 'B' },
]);

// Check results
results.forEach(result => {
  if (result.success) {
    console.log(`‚úì ${result.path}`);
  } else {
    console.error(`‚úó ${result.path}: ${result.error}`);
  }
});

// Batch delete files
const results = await sandbox.file.batchWrite([
  { path: '/project/old.txt', operation: 'delete' },
  { path: '/project/temp.txt', operation: 'delete' },
]);

// Mixed operations (write and delete)
const results = await sandbox.file.batchWrite([
  { path: '/project/new.txt', operation: 'write', content: 'New file' },
  { path: '/project/old.txt', operation: 'delete' },
  { path: '/project/updated.txt', operation: 'write', content: 'Updated content' },
]);

// Deduplication - last operation wins when targeting same path
const results = await sandbox.file.batchWrite([
  { path: '/project/config.txt', operation: 'write', content: 'First version' },
  { path: '/project/config.txt', operation: 'write', content: 'Second version' },
  { path: '/project/config.txt', operation: 'write', content: 'Final version' },
]);

// Only one file is created with the last content
const content = await sandbox.file.retrieve('/project/config.txt');
console.log(content); // 'Final version'
```

**Notes:**

* Deduplication: If multiple operations target the same path, the last operation wins
* File locking: Prevents race conditions during batch operations
* Deterministic ordering: Operations are processed in alphabetical order by path
* Partial failure handling: Returns per-file success/error results, allowing you to handle failures individually



***

### `file.exists(path)`

[Section titled ‚Äúfile.exists(path)‚Äù](#fileexistspath)

Check if a file or directory exists.

**Parameters:**

* `path` (string, required): File or directory path

**Returns:** `Promise<boolean>` - `true` if path exists, `false` otherwise

**Examples:**

```
// Basic file existence check
const exists = await sandbox.file.exists('/project/hello.txt');
if (exists) {
  console.log('File exists!');
} else {
  console.log('File not found');
}
// Output: File exists! (if file exists) or File not found (if it doesn't)

// Check directory existence
const dirExists = await sandbox.file.exists('/project/src');
console.log(dirExists); // true (works for directories too)

// Check non-existent path (returns false, no error)
const missing = await sandbox.file.exists('/project/nonexistent.txt');
console.log(missing); // false (never throws an error)

// Defensive pattern before read
const configPath = '/project/config.json';
if (await sandbox.file.exists(configPath)) {
  const config = await sandbox.file.retrieve(configPath);
  console.log('Config loaded:', config);
} else {
  console.log('Config file not found');
}

// Defensive pattern before write (avoid overwrite)
const outputPath = '/project/report.txt';
if (await sandbox.file.exists(outputPath)) {
  console.log('File already exists, skipping write');
} else {
  await sandbox.file.create(outputPath, 'New report content');
  console.log('File created successfully');
}
```

**Notes:**

* Unlike `retrieve()` or `list()`, `exists()` always returns `false` for non-existent paths instead of throwing an error. This makes it safe to call without try/catch blocks and ideal for conditional logic.
* Returns `true` for any path that exists in the filesystem, whether it‚Äôs a file or directory.
* Use `exists()` before operations to avoid errors (before read), prevent overwrites (before write), or skip unnecessary operations (before delete).
* Available on all sandbox instances regardless of provider.



***

## `sandbox.watcher`

[Section titled ‚Äúsandbox.watcher‚Äù](#sandboxwatcher)

Real-time file system monitoring.

### `watcher.create(path, options?)`

[Section titled ‚Äúwatcher.create(path, options?)‚Äù](#watchercreatepath-options)

Create a file watcher to monitor filesystem changes in real-time.

**Parameters:**

* `path` (string, required): Directory or file path to watch

* `options` (object, optional):

  * `includeContent` (boolean): Include file content in change events (default: false)
  * `ignored` (string\[]): Glob patterns to ignore (e.g., `['node_modules', '.git']`)
  * `encoding` (‚Äòraw‚Äô | ‚Äòbase64‚Äô): Content encoding, ‚Äòraw‚Äô (default) or ‚Äòbase64‚Äô for binary-safe content

**Returns:** `Promise<FileWatcher>` - FileWatcher instance with event handling

**Examples:**

```
// Basic watcher creation
const watcher = await sandbox.watcher.create('/project/src');
watcher.on('change', (event) => {
  console.log(`${event.event}: ${event.path}`);
});
// Logs: add: /project/src/app.ts (when files are added)
//       change: /project/src/app.ts (when files are modified)
//       unlink: /project/src/app.ts (when files are deleted)

// Watch with ignored patterns
const watcher = await sandbox.watcher.create('/project', {
  ignored: ['node_modules', '.git', '*.log', 'dist']
}); // Only monitors changes outside of node_modules, .git, log files, and dist

// Watch with content included
const watcher = await sandbox.watcher.create('/project/config', {
  includeContent: true
});
watcher.on('change', (event) => {
  console.log(`File ${event.event}: ${event.path}`);
  if (event.content) {
    console.log('New content:', event.content);
  }
}); // Output includes full file content for each change event
```

**Notes:**

* Watchers emit five event types: `'add'` (file created), `'change'` (file modified), `'unlink'` (file deleted), `'addDir'` (directory created), `'unlinkDir'` (directory deleted).
* Set `includeContent: false` (default) for better performance when you only need to know which files changed, not their contents. Enable `includeContent: true` only when you need the actual file content.
* Use glob patterns to exclude directories like `node_modules` or `.git` to reduce noise and improve performance. Patterns are matched against the full path.
* Available on all sandbox instances regardless of provider.



***

### `watcher.list()`

[Section titled ‚Äúwatcher.list()‚Äù](#watcherlist)

List all active file watchers in the sandbox.

**Parameters:** None

**Returns:** `Promise<WatcherInfo[]>` - Array of watcher information objects

**Examples:**

```
// Basic list all watchers
const watchers = await sandbox.watcher.list();
console.log(`Active watchers: ${watchers.length}`);
watchers.forEach(w => {
  console.log(`ID: ${w.id}, Path: ${w.path}, Status: ${w.status}`);
}); // Output: ID: watcher_123, Path: /project/src, Status: active

// Empty list handling
const watchers = await sandbox.watcher.list();
if (watchers.length === 0) {
  console.log('No active watchers');
} else {
  console.log(`Found ${watchers.length} active watcher(s)`);
}

// Check if specific path is being watched
const watchers = await sandbox.watcher.list();
const targetPath = '/project/config';
const isWatched = watchers.some(w => w.path === targetPath);
console.log(`Path ${targetPath} is ${isWatched ? 'being watched' : 'not watched'}`);
```

**Notes:**

* Each watcher object includes `id`, `path`, `includeContent`, `ignored`, `status`, `channel`, and `encoding`.
* Watchers can have status `'active'` (currently monitoring) or `'stopped'` (no longer monitoring).
* Returns the current state of all watchers. Create new watchers with `watcher.create()` and they will appear in subsequent `list()` calls.
* Available on all sandbox instances regardless of provider.



***

### `watcher.retrieve(id)`

[Section titled ‚Äúwatcher.retrieve(id)‚Äù](#watcherretrieveid)

Retrieve information about a specific file watcher by its ID.

**Parameters:**

* `id` (string, required): The watcher ID

**Returns:** `Promise<WatcherInfo>` - Watcher information object

**Examples:**

```
// Basic retrieve watcher info
const watcher = await sandbox.watcher.create('/project/src');
const watcherId = watcher.getId();

const info = await sandbox.watcher.retrieve(watcherId);
console.log('Path:', info.path); // /project/src
console.log('Status:', info.status); // active

// Check watcher status
const watcherId = 'watcher_abc123';
const info = await sandbox.watcher.retrieve(watcherId);
if (info.status === 'active') {
  console.log('Watcher is actively monitoring');
} else {
  console.log('Watcher has been stopped');
}

// Get watcher configuration
const info = await sandbox.watcher.retrieve(watcherId);
console.log('Watching:', info.path);
console.log('Content included:', info.includeContent);
console.log('Ignored patterns:', info.ignored);
console.log('Encoding:', info.encoding || 'raw');
```

**Notes:**

* If the watcher ID doesn‚Äôt exist, this method will throw an error. Use `list()` first if you‚Äôre unsure whether a watcher exists.
* Returns the current state of the watcher at the moment of the call. The watcher‚Äôs status can change if it‚Äôs destroyed.
* Useful for verifying watcher configuration, checking if a watcher is still active, or debugging watcher setup.
* Available on all sandbox instances regardless of provider.



***

### `watcher.destroy(id)`

[Section titled ‚Äúwatcher.destroy(id)‚Äù](#watcherdestroyid)

Destroy a file watcher by its ID, stopping all monitoring.

**Parameters:**

* `id` (string, required): The watcher ID to destroy

**Returns:** `Promise<void>`

**Examples:**

```
// Basic destroy by ID
const watcher = await sandbox.watcher.create('/project/src');
const watcherId = watcher.getId();

await sandbox.watcher.destroy(watcherId);
console.log('Watcher destroyed');


// Destroy multiple watchers
const watchers = await sandbox.watcher.list();
for (const w of watchers) {
  await sandbox.watcher.destroy(w.id);
}
console.log('All watchers destroyed');


// Destroy and verify
const watcherId = watcher.getId();
await sandbox.watcher.destroy(watcherId);

const remaining = await sandbox.watcher.list();
const stillExists = remaining.some(w => w.id === watcherId);
console.log('Destroyed:', !stillExists); // true
```

**Notes:**

* `sandbox.watcher.destroy(id)` takes a watcher ID parameter. The FileWatcher instance also has a [`destroy()`](#destroy-2) method that takes no parameters: `watcher.destroy()`. Both accomplish the same result.
* Destroying an already-destroyed watcher will throw an error. Use defensive checks with `list()` if you‚Äôre unsure.
* Available on all sandbox instances regardless of provider.



***

### FileWatcher Instance

[Section titled ‚ÄúFileWatcher Instance‚Äù](#filewatcher-instance)

The `FileWatcher` instance returned by `watcher.create()` provides event-based monitoring and management methods.

**Getter Methods:**

* `getId()`: Returns the watcher ID (string)
* `getPath()`: Returns the watched path (string)
* `getStatus()`: Returns watcher status (‚Äòactive‚Äô | ‚Äòstopped‚Äô)
* `getChannel()`: Returns the WebSocket channel (string)
* `isIncludingContent()`: Returns true if content is included in events (boolean)
* `getIgnoredPatterns()`: Returns array of ignored patterns (string\[])
* `isActive()`: Returns true if watcher is active (boolean)

**Example:**

```
const watcher = await sandbox.watcher.create('/project/src', {
  includeContent: true,
  ignored: ['*.test.ts']
});

console.log('ID:', watcher.getId());              // watcher_abc123
console.log('Path:', watcher.getPath());          // /project/src
console.log('Status:', watcher.getStatus());      // active
console.log('Active:', watcher.isActive());       // true
console.log('Content:', watcher.isIncludingContent()); // true
console.log('Ignored:', watcher.getIgnoredPatterns());  // ['*.test.ts']
```

***

#### `on(event, handler)`

[Section titled ‚Äúon(event, handler)‚Äù](#onevent-handler)

Register an event handler for file changes or watcher destruction.

**Parameters:**

* `event` (‚Äòchange‚Äô | ‚Äòdestroyed‚Äô, required): Event type to listen for

* `handler` (function, required): Event handler function

  * For ‚Äòchange‚Äô: `(event: FileChangeEvent) => void`
  * For ‚Äòdestroyed‚Äô: `() => void`

**FileChangeEvent properties:**

* `event`: ‚Äòadd‚Äô | ‚Äòchange‚Äô | ‚Äòunlink‚Äô | ‚ÄòaddDir‚Äô | ‚ÄòunlinkDir‚Äô
* `path`: File or directory path (string)
* `content`: File content (string, only if `includeContent: true`)

**Returns:** void

**Examples:**

```
// Basic change event listener
const watcher = await sandbox.watcher.create('/project/src');
watcher.on('change', (event) => {
  console.log(`${event.event}: ${event.path}`);
});
// Output: change: /project/src/app.ts
//         add: /project/src/utils.ts
//         unlink: /project/src/old.ts

// Handle different event types
const watcher = await sandbox.watcher.create('/project');
watcher.on('change', (event) => {
  switch (event.event) {
    case 'add':
      console.log('File created:', event.path);
      break;
    case 'change':
      console.log('File modified:', event.path);
      break;
    case 'unlink':
      console.log('File deleted:', event.path);
      break;
    case 'addDir':
      console.log('Directory created:', event.path);
      break;
    case 'unlinkDir':
      console.log('Directory deleted:', event.path);
      break;
  }
});

// Access file content in events
const watcher = await sandbox.watcher.create('/project/config', {
  includeContent: true
});
watcher.on('change', (event) => {
  console.log(`${event.event}: ${event.path}`);
  if (event.content) {
    console.log('Content length:', event.content.length);
    console.log('First 100 chars:', event.content.substring(0, 100));
  }
});
```

**Notes:**

* You can register multiple handlers for the same event. All handlers will be called when the event fires.
* The `content` property is only present in change events if the watcher was created with `includeContent: true`.
* Change events are emitted in the order they occur. If multiple files change simultaneously, you‚Äôll receive multiple events.
* The ‚Äòdestroyed‚Äô event fires when the watcher is destroyed (via `destroy()` or `sandbox.watcher.destroy(id)`), allowing cleanup of resources.



***

#### `off(event, handler)`

[Section titled ‚Äúoff(event, handler)‚Äù](#offevent-handler)

Unregister an event handler to stop receiving notifications.

**Parameters:**

* `event` (‚Äòchange‚Äô | ‚Äòdestroyed‚Äô, required): Event type
* `handler` (function, required): The specific handler function to remove

**Returns:** void

**Examples:**

```
// Basic remove handler
const watcher = await sandbox.watcher.create('/project/src');

const changeHandler = (event) => {
  console.log('Change:', event.path);
};

watcher.on('change', changeHandler);
  // Later, stop listening
watcher.off('change', changeHandler);

// Remove specific handler from multiple
const watcher = await sandbox.watcher.create('/project/src');

const handler1 = (event) => console.log('Handler 1:', event.path);
const handler2 = (event) => console.log('Handler 2:', event.path);

watcher.on('change', handler1);
watcher.on('change', handler2);

  // Remove only handler1, handler2 continues to receive events
watcher.off('change', handler1);

// Temporary listener pattern
const watcher = await sandbox.watcher.create('/project/build');

const buildCompleteHandler = (event) => {
  if (event.path.endsWith('build-complete.txt')) {
    console.log('Build complete!');
    // Stop listening after detecting completion
    watcher.off('change', buildCompleteHandler);
  }
};

watcher.on('change', buildCompleteHandler);
```

**Notes:**

* You must pass the exact same function reference that was used with `on()`. Anonymous functions cannot be removed unless you store a reference.
* Calling `off()` with a handler that wasn‚Äôt registered has no effect and doesn‚Äôt throw an error.
* Always remove event handlers when you‚Äôre done with them to prevent memory leaks, especially in long-running applications.



***

#### `destroy()`

[Section titled ‚Äúdestroy()‚Äù](#destroy)

Destroy the watcher instance, stopping all monitoring and cleanup resources.

**Parameters:** None

**Returns:** `Promise<void>`

**Examples:**

```
// Basic destroy instance
const watcher = await sandbox.watcher.create('/project/src');
watcher.on('change', (event) => {
  console.log('Change:', event.path);
});

  // Later, when done monitoring
await watcher.destroy();
console.log('Watcher stopped');


// Destroy after one-time operation
const watcher = await sandbox.watcher.create('/project/output');

watcher.on('change', async (event) => {
  if (event.path.endsWith('result.json')) {
    console.log('Result file created, cleaning up');
    await watcher.destroy();
  }
});
```

**Notes:**

* When you call `destroy()`, the watcher automatically unsubscribes from WebSocket events and clears all event handlers.
* Both `watcher.destroy()` (instance method, no parameters) and `sandbox.watcher.destroy(id)` (namespace method, requires ID) accomplish the same result.



***

## `sandbox.signals`

[Section titled ‚Äúsandbox.signals‚Äù](#sandboxsignals)

Monitor system events and emit custom signals via WebSocket.



***

### `signals.start()`

[Section titled ‚Äúsignals.start()‚Äù](#signalsstart)

Start the signal service to monitor system events via WebSocket.

**Parameters:** None

**Returns:** `Promise<SignalService>` - SignalService instance with event handling

**SignalService interface:**

* Event methods: `on()`, `off()`, `stop()`
* Getter methods: `getStatus()`, `getChannel()`, `isActive()`

**Examples:**

```
// Start signal monitoring
const signals = await sandbox.signals.start();

// Listen for port signals
signals.on('port', (event) => {
  console.log(`Port ${event.port} ${event.type}: ${event.url}`);
});

// Listen for error signals
signals.on('error', (event) => {
  console.error('Error:', event.message);
});

// Check status
console.log('Active:', signals.isActive());  // true
console.log('Status:', signals.getStatus()); // 'active'
console.log('Channel:', signals.getChannel()); // 'signals-channel-123'

// Stop when done
await signals.stop();
```

**Notes:**

* Returns a `SignalService` instance for monitoring events
* Requires WebSocket connection to receive events
* Multiple event handlers can be registered for the same event type
* Available on all sandbox instances regardless of provider



***

### `signals.status()`

[Section titled ‚Äúsignals.status()‚Äù](#signalsstatus)

Get the current status of the signal service.

**Parameters:** None

**Returns:** `Promise<SignalStatusInfo>` - Signal service status information

**SignalStatusInfo interface:**

* `status` (‚Äòactive‚Äô | ‚Äòstopped‚Äô): Current service status
* `channel` (string): WebSocket channel identifier
* `wsUrl` (string): WebSocket URL

**Examples:**

```
// Get signal service status
const status = await sandbox.signals.status();
console.log(status.status);   // 'active' or 'stopped'
console.log(status.channel);  // 'signals-channel-123'
console.log(status.wsUrl);    // 'wss://...'

// Check if service is active before emitting
const status = await sandbox.signals.status();
if (status.status === 'active') {
  await sandbox.signals.emitPort(3000, 'open', 'http://localhost:3000');
}
```

**Notes:**

* Returns current state without requiring a `SignalService` instance
* Use this to check status before calling other signal methods
* Available on all sandbox instances regardless of provider



***

### `signals.stop()`

[Section titled ‚Äúsignals.stop()‚Äù](#signalsstop)

Stop the signal service (namespace method).

**Parameters:** None

**Returns:** `Promise<void>`

**Examples:**

```
// Stop signal service via namespace
await sandbox.signals.stop();
console.log('Signal service stopped');

// Alternative: stop via instance
const signals = await sandbox.signals.start();
await signals.stop();
```

**Notes:**

* This is a namespace method - can be called directly on `sandbox.signals`
* The `SignalService` instance also has a `stop()` method
* Both accomplish the same result
* Available on all sandbox instances regardless of provider



***

### `signals.emitPort(port, type, url)`

[Section titled ‚Äúsignals.emitPort(port, type, url)‚Äù](#signalsemitportport-type-url)

Emit a port signal to notify about port status changes.

**Parameters:**

* `port` (number, required): Port number
* `type` (‚Äòopen‚Äô | ‚Äòclose‚Äô, required): Signal type indicating port status
* `url` (string, required): URL associated with the port

**Returns:** `Promise<void>`

**Examples:**

```
// Emit port opened signal
await sandbox.signals.emitPort(3000, 'open', 'http://localhost:3000');

// Emit port closed signal
await sandbox.signals.emitPort(3000, 'close', 'http://localhost:3000');

// Notify about server starting
await sandbox.signals.emitPort(8080, 'open', 'https://myapp.example.com');
console.log('Port signal emitted');
```

**Notes:**

* Use ‚Äòopen‚Äô type when a port becomes available
* Use ‚Äòclose‚Äô type when a port is no longer available
* Requires signal service to be started to receive events
* Available on all sandbox instances regardless of provider



***

### `signals.emitError(message)`

[Section titled ‚Äúsignals.emitError(message)‚Äù](#signalsemiterrormessage)

Emit an error signal to notify about errors in the sandbox.

**Parameters:**

* `message` (string, required): Error message

**Returns:** `Promise<void>`

**Examples:**

```
// Emit error signal
await sandbox.signals.emitError('Database connection failed');

// Error in application code
try {
  await riskyOperation();
} catch (error) {
  await sandbox.signals.emitError(`Operation failed: ${error.message}`);
}

// Custom error notifications
await sandbox.signals.emitError('Configuration file missing');
```

**Notes:**

* Use for application-level errors or notifications
* Requires signal service to be started to receive events
* Available on all sandbox instances regardless of provider



***

### `signals.emitServerReady(port, url)`

[Section titled ‚Äúsignals.emitServerReady(port, url)‚Äù](#signalsemitserverreadyport-url)

Emit a server ready signal to notify when a server is ready to accept connections.

**Parameters:**

* `port` (number, required): Port number where server is listening
* `url` (string, required): Server URL

**Returns:** `Promise<void>`

**Examples:**

```
// Notify server is ready
await sandbox.signals.emitServerReady(3000, 'http://localhost:3000');

// After starting Express server
const app = express();
app.listen(3000, async () => {
  await sandbox.signals.emitServerReady(3000, 'http://localhost:3000');
  console.log('Server ready signal emitted');
});

// Multiple servers
await sandbox.signals.emitServerReady(3000, 'http://localhost:3000'); // API
await sandbox.signals.emitServerReady(8080, 'http://localhost:8080'); // WebSocket
```

**Notes:**

* Specialized signal for server readiness (distinct from port open)
* Useful for coordinating application startup
* Requires signal service to be started to receive events
* Available on all sandbox instances regardless of provider



***

## SignalService Instance

[Section titled ‚ÄúSignalService Instance‚Äù](#signalservice-instance)

The `SignalService` instance returned by `signals.start()` provides event handling and management methods.

### `on(event, handler)`

[Section titled ‚Äúon(event, handler)‚Äù](#onevent-handler-1)

Register an event handler for signal events.

**Parameters:**

* `event` (‚Äòport‚Äô | ‚Äòerror‚Äô | ‚Äòsignal‚Äô, required): Event type to listen for

* `handler` (function, required): Event handler function

  * For ‚Äòport‚Äô: `(event: PortSignalEvent) => void`
  * For ‚Äòerror‚Äô: `(event: ErrorSignalEvent) => void`
  * For ‚Äòsignal‚Äô: `(event: SignalEvent) => void`

**Event Types:**

* `PortSignalEvent`: `{ signal: 'port' | 'server-ready', port: number, url: string, type?: 'open' | 'close' }`
* `ErrorSignalEvent`: `{ signal: 'error', message: string }`
* `SignalEvent`: Union of all event types

**Returns:** void

**Examples:**

```
const signals = await sandbox.signals.start();

// Listen for port events
signals.on('port', (event) => {
  console.log(`Signal: ${event.signal}`);
  console.log(`Port: ${event.port} - ${event.url}`);
  if (event.type) {
    console.log(`Type: ${event.type}`);
  }
});

// Listen for error events
signals.on('error', (event) => {
  console.error(`Error signal: ${event.message}`);
});

// Listen for all signal events (generic)
signals.on('signal', (event) => {
  console.log('Signal received:', event);
});

// Multiple handlers for same event
const handler1 = (event) => console.log('Handler 1:', event.port);
const handler2 = (event) => console.log('Handler 2:', event.port);

signals.on('port', handler1);
signals.on('port', handler2);
// Both handlers will be called
```

**Notes:**

* Multiple handlers can be registered for the same event type
* All handlers are called when an event fires
* The ‚Äòport‚Äô event includes both port signals and server-ready signals
* The ‚Äòsignal‚Äô event is a generic listener that receives all signal types
* Handler errors are caught and logged to console without stopping other handlers



***

### `off(event, handler)`

[Section titled ‚Äúoff(event, handler)‚Äù](#offevent-handler-1)

Unregister an event handler to stop receiving notifications.

**Parameters:**

* `event` (‚Äòport‚Äô | ‚Äòerror‚Äô | ‚Äòsignal‚Äô, required): Event type
* `handler` (function, required): The specific handler function to remove

**Returns:** void

**Examples:**

```
const signals = await sandbox.signals.start();

// Register handler
const portHandler = (event) => {
  console.log('Port event:', event.port);
};
signals.on('port', portHandler);

// Later, remove handler
signals.off('port', portHandler);

// Remove specific handler from multiple
const handler1 = (event) => console.log('Handler 1');
const handler2 = (event) => console.log('Handler 2');

signals.on('error', handler1);
signals.on('error', handler2);

signals.off('error', handler1); // Only handler2 continues to receive events

// Cleanup pattern
const cleanup = () => {
  signals.off('port', portHandler);
  signals.off('error', errorHandler);
};
```

**Notes:**

* Must pass the exact same function reference used with `on()`
* Anonymous functions cannot be removed unless you store a reference
* No error if handler wasn‚Äôt registered
* Use for cleanup when you no longer need specific handlers



***

### `stop()`

[Section titled ‚Äústop()‚Äù](#stop)

Stop the signal service instance and clean up resources.

**Parameters:** None

**Returns:** `Promise<void>`

**Examples:**

```
// Stop via instance method
const signals = await sandbox.signals.start();
signals.on('port', (event) => console.log(event));

// Later, stop monitoring
await signals.stop();
console.log('Signal service stopped');

// Cleanup pattern with finally
let signals;
try {
  signals = await sandbox.signals.start();
  signals.on('port', (event) => console.log(event));
  // ... work ...
} finally {
  if (signals) {
    await signals.stop();
  }
}
```

**Notes:**

* Makes POST request to `/signals/stop`
* Cleans up WebSocket subscriptions and event handlers
* Sets status to ‚Äòstopped‚Äô
* Alternative to namespace method `sandbox.signals.stop()`



***

### Getter Methods

[Section titled ‚ÄúGetter Methods‚Äù](#getter-methods)

The `SignalService` instance provides getter methods to inspect its state.

**`getStatus()`** - Returns current status (‚Äòactive‚Äô | ‚Äòstopped‚Äô)

```
const signals = await sandbox.signals.start();
console.log(signals.getStatus()); // 'active'
```

**`getChannel()`** - Returns WebSocket channel identifier

```
const signals = await sandbox.signals.start();
console.log(signals.getChannel()); // 'signals-channel-123'
```

**`isActive()`** - Returns true if service is active

```
const signals = await sandbox.signals.start();
console.log(signals.isActive()); // true

await signals.stop();
console.log(signals.isActive()); // false
```



***

## sandbox.sessionTokens

[Section titled ‚Äúsandbox.sessionTokens‚Äù](#sandboxsessiontokens)

Manage session tokens for delegated access. Session tokens provide temporary, scoped access to a sandbox without requiring the primary access token.

**Important:** All sessionToken methods require an **access token**. Session tokens cannot manage themselves (403 Forbidden).



***

### `sessionTokens.create(options?)`

[Section titled ‚ÄúsessionTokens.create(options?)‚Äù](#sessiontokenscreateoptions)

Create a new session token for delegated access to the sandbox.

**Parameters:**

* `options` (object, optional): Token configuration

  * `description` (string, optional): Human-readable description for the token
  * `expiresIn` (number, optional): Expiration time in seconds (default: 604800 = 7 days)

**Returns:** `Promise<SessionTokenInfo>` - Session token information including the token value

**SessionTokenInfo interface (create only):**

* `id` (string): Unique token identifier
* `token` (string): The actual token value - **ONLY returned on creation, cannot be retrieved later!**
* `description` (string, optional): Token description
* `createdAt` (string): ISO timestamp when token was created
* `expiresAt` (string): ISO timestamp when token expires

**Examples:**

```
// Basic token creation with default expiration (7 days)
const token = await sandbox.sessionTokens.create();
console.log(token.token);      // "st_abc123..." - Save this!
console.log(token.id);         // "token_xyz789"
console.log(token.expiresAt);  // "2024-01-15T12:00:00Z"

// Token with description
const token = await sandbox.sessionTokens.create({
  description: 'My Application'
});
console.log(token.description); // "My Application"

// Token with custom expiration (1 hour = 3600 seconds)
const token = await sandbox.sessionTokens.create({
  description: 'Short-lived token',
  expiresIn: 3600
});

// Save token immediately - it won't be available later!
const token = await sandbox.sessionTokens.create({
  description: 'Production API'
});
const tokenValue = token.token; // Save this now!
// Later calls to retrieve() or list() will NOT include the token value

// Use token to create a new sandbox connection
const delegatedSandbox = new Sandbox({
  sandboxUrl: 'https://sandbox-123.computesdk.com',
  token: token.token  // Use session token instead of access token
});
```

**Notes:**

* ‚ö†Ô∏è **Critical:** The `token` field is ONLY returned once at creation time - store it securely immediately!
* Requires an **access token** to call (403 Forbidden if called with a session token)
* Default expiration is 7 days (604800 seconds)
* Token becomes invalid after expiration or revocation
* Use session tokens to delegate access without exposing your primary access token
* Available on all sandbox instances regardless of provider



***

### `sessionTokens.list()`

[Section titled ‚ÄúsessionTokens.list()‚Äù](#sessiontokenslist)

List all session tokens for the current sandbox.

**Parameters:** None

**Returns:** `Promise<SessionTokenInfo[]>` - Array of session token information

**SessionTokenInfo interface (list):**

* `id` (string): Unique token identifier
* `description` (string, optional): Token description
* `createdAt` (string): ISO timestamp when token was created
* `expiresAt` (string): ISO timestamp when token expires
* `lastUsedAt` (string, optional): ISO timestamp of last usage (undefined if never used)

**Note:** The actual `token` value is **NOT included** in list results.

**Examples:**

```
// List all tokens
const tokens = await sandbox.sessionTokens.list();
console.log(`Found ${tokens.length} tokens`);

// Display token information
const tokens = await sandbox.sessionTokens.list();
tokens.forEach(token => {
  console.log(`ID: ${token.id}`);
  console.log(`Description: ${token.description || 'None'}`);
  console.log(`Created: ${token.createdAt}`);
  console.log(`Expires: ${token.expiresAt}`);
  console.log(`Last used: ${token.lastUsedAt || 'Never'}`);
});

// Find tokens by description
const tokens = await sandbox.sessionTokens.list();
const prodToken = tokens.find(t => t.description === 'Production API');

// Check for expired tokens
const tokens = await sandbox.sessionTokens.list();
const now = new Date();
const expiredTokens = tokens.filter(t => new Date(t.expiresAt) < now);
console.log(`${expiredTokens.length} tokens have expired`);
```

**Notes:**

* ‚ö†Ô∏è The actual `token` value is NOT included - use `create()` to get the token value
* Requires an **access token** to call (403 Forbidden if called with a session token)
* Returns empty array if no tokens exist
* Includes `lastUsedAt` to track when token was last used
* Available on all sandbox instances regardless of provider



***

### `sessionTokens.retrieve(id)`

[Section titled ‚ÄúsessionTokens.retrieve(id)‚Äù](#sessiontokensretrieveid)

Retrieve detailed information about a specific session token by ID.

**Parameters:**

* `id` (string, required): The token ID to retrieve

**Returns:** `Promise<SessionTokenInfo>` - Session token information

**SessionTokenInfo interface (retrieve):**

* `id` (string): Unique token identifier
* `description` (string, optional): Token description
* `createdAt` (string): ISO timestamp when token was created
* `expiresAt` (string): ISO timestamp when token expires

**Note:** The actual `token` value and `lastUsedAt` field are **NOT included** in retrieve results.

**Examples:**

```
// Retrieve specific token
const token = await sandbox.sessionTokens.retrieve('token_abc123');
console.log(token.id);          // "token_abc123"
console.log(token.description); // "My Application"
console.log(token.expiresAt);   // "2024-01-15T12:00:00Z"

// Check if token exists
try {
  const token = await sandbox.sessionTokens.retrieve('token_xyz789');
  console.log('Token exists:', token.id);
} catch (error) {
  console.error('Token not found');
}

// Check expiration
const token = await sandbox.sessionTokens.retrieve('token_abc123');
const expiresAt = new Date(token.expiresAt);
const now = new Date();
if (expiresAt < now) {
  console.log('Token has expired');
  await sandbox.sessionTokens.revoke(token.id);
} else {
  const hoursRemaining = (expiresAt - now) / (1000 * 60 * 60);
  console.log(`Token expires in ${hoursRemaining.toFixed(1)} hours`);
}
```

**Notes:**

* ‚ö†Ô∏è The actual `token` value is NOT included - cannot retrieve token value after creation
* ‚ö†Ô∏è The `lastUsedAt` field is also NOT included (unlike `list()`)
* Requires an **access token** to call (403 Forbidden if called with a session token)
* Throws error if token ID doesn‚Äôt exist
* Available on all sandbox instances regardless of provider



***

### `sessionTokens.revoke(id)`

[Section titled ‚ÄúsessionTokens.revoke(id)‚Äù](#sessiontokensrevokeid)

Revoke (delete) a session token, immediately invalidating it and preventing further use.

**Parameters:**

* `id` (string, required): The token ID to revoke

**Returns:** `Promise<void>` - Resolves when token is successfully revoked

**Examples:**

```
// Basic revocation
await sandbox.sessionTokens.revoke('token_abc123');
console.log('Token revoked');

// Revoke expired tokens
const tokens = await sandbox.sessionTokens.list();
const now = new Date();
for (const token of tokens) {
  if (new Date(token.expiresAt) < now) {
    await sandbox.sessionTokens.revoke(token.id);
    console.log(`Revoked expired token: ${token.id}`);
  }
}

// Safe revocation with error handling
try {
  await sandbox.sessionTokens.revoke('token_xyz789');
  console.log('Token revoked successfully');
} catch (error) {
  console.error('Revocation failed:', error.message);
}

// Revoke all tokens
const tokens = await sandbox.sessionTokens.list();
await Promise.all(
  tokens.map(token => sandbox.sessionTokens.revoke(token.id))
);
console.log('All tokens revoked');
```

**Notes:**

* Requires an **access token** to call (403 Forbidden if called with a session token)
* Revocation is immediate and permanent - the token cannot be used after this call
* Does not throw error if token doesn‚Äôt exist or was already revoked
* Once revoked, any sandbox connections using this token will fail with authentication errors
* Use this to clean up expired or compromised tokens
* Available on all sandbox instances regardless of provider



***

## `sandbox.magicLinks`

[Section titled ‚Äúsandbox.magicLinks‚Äù](#sandboxmagiclinks)

Create one-time authentication URLs for browser-based access. Magic links provide passwordless authentication by automatically creating session tokens and setting them as secure cookies.

**Important:** Requires an **access token** to create magic links (403 Forbidden if called with a session token).



***

### `magicLinks.create(options?)`

[Section titled ‚ÄúmagicLinks.create(options?)‚Äù](#magiclinkscreateoptions)

Create a one-time magic link URL for browser-based authentication.

**Parameters:**

* `options` (object, optional): Magic link configuration
  * `redirectUrl` (string, optional): URL path to redirect to after authentication (default: `/play/`)

**Returns:** `Promise<MagicLinkInfo>` - Magic link information including the URL

**MagicLinkInfo interface:**

* `url` (string): The magic link URL to share with users
* `expiresAt` (string): ISO timestamp when the link expires
* `redirectUrl` (string): The redirect URL configured for this link

**Examples:**

```
// Basic magic link with default redirect
const link = await sandbox.magicLinks.create();
console.log(link.url);         // "https://sandbox-123.computesdk.com/auth/magic/abc123..."
console.log(link.expiresAt);   // "2024-01-09T12:05:00Z" (5 minutes from now)
console.log(link.redirectUrl); // "/play/"

// Magic link with custom redirect
const link = await sandbox.magicLinks.create({
  redirectUrl: '/dashboard'
});
console.log(link.redirectUrl); // "/dashboard"
```

**Notes:**

* ‚ö†Ô∏è **One-time use:** Link expires after first click or 5 minutes (whichever comes first)
* ‚ö†Ô∏è **Security:** Session token is set as HttpOnly cookie, preventing XSS attacks
* Requires an **access token** to call (403 Forbidden if called with a session token)
* Magic link expires after **5 minutes** or first use
* Automatically creates a **session token** with **7-day expiration**
* Session token is set as an **HttpOnly cookie** (not accessible via JavaScript)
* Default redirect is `/play/` if `redirectUrl` is not specified
* Relative URLs only - `redirectUrl` should be a path, not a full URL
* Available on all sandbox instances regardless of provider



***

# Features Page

> Features by Compute SDK.

<!-- Feature Hero -->

## The same sandbox features with any provider.

Build once with ComputeSDK and get the same experience across any sandbox or cloud provider.

[Get Started](https://console.computesdk.com/register) [Talk to Sales ‚Üí](/sales)

![Geometric pattern](/cube-design-light.svg) ![Geometric pattern](/cube-design-dark.svg)

<!-- Features Grid -->

<!-- Badge -->

<!-- <div class="mb-12 mx-auto text-center">
          <span class="inline-flex items-center bg-emerald-600/10 dark:bg-emerald-900/50 px-4 py-1.5 text-sm font-semibold text-emerald-800 dark:text-white ring-1 ring-inset ring-emerald-600/10 rounded-xs">
            Features
          </span>
        </div> -->

### Features Developers Love

* Multi-provider Support

  Use E2B, Vercel, Daytona, Modal, CodeSandbox and more without code changes. Provider-agnostic design means no re-writes for new providers.

  Real-time Terminal Access

  Create and manage persistent terminal sessions with WebSocket connectivity for interactive development and debugging.

  Complete Filesystem Control

  Full CRUD operations on files and directories with real-time file watching and change notifications across all providers.

  TypeScript-Native API

  Full TypeScript support with comprehensive error handling, making development safer and more productive.

  Process Signal Management

  Start, stop, and monitor processes with port forwarding and server readiness detection for complete process control.

  JWT-Secured Endpoints

  First-come-first-served authentication model with token-based access control for secure code execution environments.

  One-off Command Execution

  Execute commands instantly without spinning up persistent terminals for quick tasks and automated workflows.

  WebSocket Communication

  Low-latency bidirectional communication for real-time updates and interactive sessions with your sandbox environments.

  Health Monitoring

  Built-in health checks and status endpoints for reliability and observability of your code execution infrastructure.

<!-- CTA section -->

## Ready to streamline your sandbox development?

Use ComputeSDK with any sandbox or cloud provider and start building sandboxes in minutes.

[Get Started](https://console.computesdk.com/register) [Talk to Sales ‚Üí](/sales)

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Sandboxes Feature Page

> Sandbox within a Sandbox by Compute SDK.

Features

# Sandbox within a Sandbox

Faucibus commodo massa rhoncus, volutpat. Dignissim sed eget risus enim. Mattis mauris semper sed amet vitae sed turpis id. Id dolor praesent donec est. Odio penatibus risus viverra tellus varius sit neque erat velit. Faucibus commodo massa rhoncus, volutpat. Dignissim sed eget risus enim. Mattis mauris semper sed amet vitae sed turpis id.

Et vitae blandit facilisi magna lacus commodo. Vitae sapien duis odio id et. Id blandit molestie auctor fermentum dignissim. Lacus diam tincidunt ac cursus in vel. Mauris varius vulputate et ultrices hac adipiscing egestas.

Erat pellentesque dictumst ligula porttitor risus eget et eget. Ultricies tellus felis id dignissim eget. Est augue maecenas risus nulla ultrices congue nunc tortor.

Et vitae blandit facilisi magna lacus commodo. Vitae sapien duis odio id et. Id blandit molestie auctor fermentum dignissim. Lacus diam tincidunt ac cursus in vel. Mauris varius vulputate et ultrices hac adipiscing egestas. Iaculis convallis ac tempor et ut. Ac lorem vel integer orci.

[Get started](#)

![](https://tailwindcss.com/plus-assets/img/component-images/project-app-screenshot.png)

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Create secure sandboxes anywhere

> Build, deploy, and interact with sandboxes using a single, consistent API across any provider - E2B, Daytona, Modal, & more.

<!-- Home page hero section -->

<!-- Left column - Content -->

<!-- Headline -->

# Create secure sandboxes anywhere

<!-- Subheadline -->

One SDK, any cloud provider. Write your sandbox implementation once and run AI agents anywhere.

<!-- Secondary CTA -->

[Get Started](https://console.computesdk.com/register) [Talk to Sales ‚Üí](/sales)

<!-- Right column - Code Block -->

<!-- Window header with tabs -->

sandbox.ts

<!-- Code content -->

```
import { compute } from 'computesdk';

// auto-detects provider from environment variables
const sandbox = compute.sandbox.create();

const result = await sandbox.runCode('print("Hello!")');
console.log(result.output); // "Hello!"

await sandbox.filesystem.writeFile('/sandbox.txt', 'Success!');

await compute.sandbox.destroy(sandbox.sandboxId);
```

<!-- Decorative gradient behind code block -->

<!-- Light Mode -->

## You choose the provider that best meets your needs

![Blaxel](/blaxel-logo-light.svg)

![Daytona](/daytona-logo-light.svg)

![E2B](/E2B-logo-light.svg)

![Modal](/modal-logo-light.svg)

![Railway](/railway-light.svg)

![Runloop](/runloop-logo-light.svg)

![Vercel](/Vercel_Logo_L.svg)

<!-- Dark Mode -->

## You choose the provider that best meets your needs

![Blaxel](/blaxel-logo-dark.svg)

![Daytona](/daytona-logo-dark.svg)

![E2B](/E2B-logo-dark.svg)

![Modal](/modal-logo-dark.svg)

![Railway](/railway-dark.svg)

![Runloop](/runloop-logo-dark.svg)

![Vercel](/Vercel_Logo_D.svg)

<!-- Section Header -->

<!-- Badge -->

Features

## Everything You Need, Out of the Box

Built for developers who want powerful sandboxes without the complexity

<!-- Features Container with 2x3 Grid -->

<!-- Top Row: 2 cells -->

### End-User Authentication

Give your users direct access to their sandboxes‚Äîno proxy required. Build client-side code editors and AI coding assistants with zero server overhead.

### Full Terminal Access

Connect to provider environments through interactive terminals from browser or backend. Complete shell access to the underlying Linux system.

<!-- Middle Row: 2 cells -->

### Interactive Terminal I/O

Full PTY support for authentic terminal experiences via WebSocket. Real-time input/output with xterm.js compatibility.

### Complete File System Control

Manage files in provider sandboxes via REST APIs. Upload datasets, scaffold projects, read build outputs with full programmatic access.

<!-- Bottom Row: Merged cell spanning 2 columns -->

### And more...

Real-time File Watching

Output Streams

WebSocket Event System

Public URLs Out of the Box

<!-- CTA Link -->

[View All Features ](/features)

<!-- Section Header -->

<!-- Badge -->

Use Cases

## Built for Modern Development

<!-- Use Cases Grid Container -->

<!-- Icon -->

![](/MaterialSymbolsDeployedCode.svg)

<!-- Content -->

### AI Code Execution

Power AI coding assistants with real-time code execution, terminal streaming, and file system control.

<!-- Icon -->

![](/MaterialSymbolsCodeBlocksOutlineSharp.svg)

<!-- Content -->

### Code Playgrounds

Build interactive coding environments with instant preview URLs, hot reload, and multi-language support.

<!-- Icon -->

![](/TdesignEducationFilled.svg)

<!-- Content -->

### Educational Platforms

Create hands-on learning experiences with isolated environments and real-time student monitoring.

<!-- CTA Link -->

[Explore All Use Cases ](/use-cases)

<!-- Headline -->

## Start Building Today

<!-- Description -->

Production-ready sandboxes are waiting for you.

<!-- Secondary CTAs -->

[Get Started](https://console.computesdk.com/register) [Talk to Sales ‚Üí](/sales)

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Pricing

> ComputeSDK has a Free tier to get started. Premium is $97/mo + usage costs ($0.0097 per sandbox).

<!-- Badge -->

Pricing

Sandboxes Made Simple

Start for free with our SDK, then scale with advanced features for production-ready sandbox environments.

### Free

$0 forever

Perfect for getting started with code execution in isolated sandbox environments.

* Multi-provider support (Blaxel, CodeSandbox, Daytona, E2B, Modal, Vercel, and more)
* Basic filesystem operations
* Command execution
* TypeScript support
* Create 100,000 sandboxes per workspace

[Get started today](https://console.computesdk.com/register)

### Premium

$97 / month

Turn any compute instance into a sandbox primitive with our self-executing binaries.

* 10,000 monthly sandbox creations included. $0.097/sandbox over 10,000.
* Real-time terminal access with WebSocket connectivity
* Complete filesystem control with real-time file watching
* One-off command execution without persistent terminals
* Process signal management with port forwarding
* JWT-secured endpoints with token-based access control
* Health monitoring with built-in status endpoints

[Get started today](https://console.computesdk.com/register)

#### Want to discuss your use case? [Contact sales](/sales)

## Pricing & Usage

Have a different question and can't find the answer you're looking for?\
[Reach out](mailto:garrison@computesdk.com) to our support team and we'll get back to you as soon as we can.

* How much does ComputeSDK cost?

  Simple: $97/month with 10,000 sandboxes included, after that, pricing is usage-based at $0.0097 per sandbox.

  What counts as a created sandbox?

  A sandox is created every time you use `compute start` directly or with the `computesdk`.

  How do API keys work?

  You'll get an API key when you sign up. Enter your key via the cli or set it as an environment variable in your project.

  How does team usage work?

  The pricing is per sandbox, not per user. So your whole team can use ComputeSDK across all your environments, simplifying the billing process.

  What if I decide I want to change providers?

  This is a core feature of ComputeSDK. You can change providers by simply updating your provider config, and all of your methods will continue to work just as before.

  Can we use this across multiple environments?

  Yes.

## Code execution, reimagined for your infrastructure.

Power real-time coding experiences, execute AI-generated code securely, and scale effortlessly on your own stack.

[Get Started](https://console.computesdk.com/register) [Talk to Sales ‚Üí](/sales)

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Privacy Policy

# Privacy Policy

**Last Updated:** January 15, 2025

Snelling, LLC ("we," "us," or "our") operates the ComputeSDK platform (the "Service"). This page informs you of our policies regarding the collection, use, and disclosure of personal data when you use our Service and the choices you have associated with that data.

## Information We Collect

### Account Information

When you create an account, we collect:

* Email address
* Name
* Company name (if applicable)
* Password (encrypted)

### Usage Information

We automatically collect information about how you use our Service:

* Log data (IP addresses, browser type, pages visited)
* Device information (operating system, device type)
* Service usage metrics and performance data
* API usage and call patterns

### Content and Code

We collect and process:

* Code and applications you develop using our platform
* Configuration files and deployment settings
* Support communications and feedback

## How We Use Your Information

We use the collected information for the following purposes:

* **Service Provision:** To provide, maintain, and improve the ComputeSDK platform
* **Account Management:** To create and manage your account and authenticate users
* **Communication:** To send service updates, security alerts, and support messages
* **Analytics:** To understand usage patterns and improve our services
* **Security:** To detect, prevent, and address technical issues and security threats
* **Legal Compliance:** To comply with applicable laws and regulations

## Information Sharing

We do not sell, trade, or otherwise transfer your personal information to third parties, except in the following circumstances:

### Service Providers

We may share information with trusted third-party service providers who assist us in:

* Cloud infrastructure and hosting
* Payment processing
* Analytics and monitoring
* Customer support tools

### Legal Requirements

We may disclose your information when required by law or in response to:

* Valid legal processes or government requests
* Protection of our rights, property, or safety
* Prevention of fraud or security threats

### Business Transfers

In the event of a merger, acquisition, or sale of assets, your information may be transferred as part of that transaction.

## Data Security

We implement appropriate security measures to protect your personal information:

* Encryption of data in transit and at rest
* Access controls and authentication
* Regular security monitoring and updates
* Employee training on data protection

However, no method of transmission over the Internet or electronic storage is 100% secure, and we cannot guarantee absolute security.

## Data Retention

We retain your personal information for as long as necessary to:

* Provide our services to you
* Comply with legal obligations
* Resolve disputes and enforce agreements

When you delete your account, we will delete your personal information within 30 days, except for information we are required to retain for legal or regulatory purposes.

## Your Rights

Depending on your location, you may have the following rights regarding your personal information:

* **Access:** Request a copy of the personal information we hold about you
* **Correction:** Request correction of inaccurate or incomplete information
* **Deletion:** Request deletion of your personal information
* **Portability:** Request transfer of your data to another service
* **Objection:** Object to processing of your personal information
* **Restriction:** Request restriction of processing

To exercise these rights, please contact us at privacy\@computesdk.com.

## Cookies and Tracking

We use cookies and similar technologies to:

* Maintain your login session
* Remember your preferences
* Analyze usage patterns
* Improve our services

You can control cookies through your browser settings, but disabling certain cookies may affect the functionality of our Service.

## International Data Transfers

Your information may be transferred to and processed in countries other than your own. We ensure appropriate safeguards are in place to protect your personal information in accordance with this privacy policy.

## Children's Privacy

Our Service is not intended for individuals under the age of 13. We do not knowingly collect personal information from children under 13. If we become aware that we have collected personal information from a child under 13, we will take steps to delete such information.

## Changes to This Privacy Policy

We may update this Privacy Policy from time to time. We will notify you of any changes by:

* Posting the new Privacy Policy on this page
* Updating the "Last Updated" date
* Sending you an email notification for material changes

## Contact Us

If you have any questions about this Privacy Policy, please contact us:

* Email: email\@computesdk.com

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Providers - ComputeSDK

> Explore ComputeSDK's provider ecosystem. Connect to leading sandbox and compute platforms with a unified API.

<!-- Header -->

# Providers

Discover the power of ComputeSDK's extensive provider ecosystem. Connect to leading sandbox and compute platforms with a unified API.

<!-- Provider Grid -->

<!-- Logo -->

[![E2B logo](/E2B-logo-light.svg)](/providers/e2b)

<!-- Category Badge -->

[SANDBOXES](/providers/e2b)

<!-- Provider Name -->

## [E2B](/providers/e2b)

<!-- Description -->

[E2B is a cloud platform for running AI-generated code in secure sandboxes. Fast-spinning, isolated environments purpose-built for LLM applications.](/providers/e2b)

<!-- Links -->

[ Docs](/providers/e2b)

<!-- Logo -->

[![Modal logo](/modal-logo-light.svg)](/providers/modal)

<!-- Category Badge -->

[SANDBOXES](/providers/modal)

<!-- Provider Name -->

## [Modal](/providers/modal)

<!-- Description -->

[Modal is a serverless cloud platform for running compute-intensive Python code. Instant container spin-up with GPU support for ML inference and data processing.](/providers/modal)

<!-- Links -->

[ Docs](/providers/modal)

<!-- Logo -->

[![Vercel logo](/vercel-logo-light.svg)](/providers/vercel)

<!-- Category Badge -->

[SANDBOXES](/providers/vercel)

<!-- Provider Name -->

## [Vercel](/providers/vercel)

<!-- Description -->

[Vercel Sandbox is a secure code execution environment built for AI applications. Isolated containers with built-in support for web technologies.](/providers/vercel)

<!-- Links -->

[ Docs](/providers/vercel)

<!-- Logo -->

[![Daytona logo](/daytona-logo-light.svg)](/providers/daytona)

<!-- Category Badge -->

[SANDBOXES](/providers/daytona)

<!-- Provider Name -->

## [Daytona](/providers/daytona)

<!-- Description -->

[Daytona is an open-source development environment manager that creates standardized, reproducible dev environments on any infrastructure.](/providers/daytona)

<!-- Links -->

[ Docs](/providers/daytona)

<!-- Logo -->

[![CodeSandbox logo](/codesandbox-logo-light.svg)](/providers/codesandbox)

<!-- Category Badge -->

[SANDBOXES](/providers/codesandbox)

<!-- Provider Name -->

## [CodeSandbox](/providers/codesandbox)

<!-- Description -->

[CodeSandbox is a cloud development platform that enables instant, collaborative coding environments for web development with modern frameworks.](/providers/codesandbox)

<!-- Links -->

[ Docs](/providers/codesandbox)

<!-- Logo -->

[![Runloop logo](/runloop-logo-light.svg)](/providers/runloop)

<!-- Category Badge -->

[SANDBOXES](/providers/runloop)

<!-- Provider Name -->

## [Runloop](/providers/runloop)

<!-- Description -->

[Runloop is a cloud platform for running secure, isolated development environments. Instant devboxes with full Linux environments for AI coding agents.](/providers/runloop)

<!-- Links -->

[ Docs](/providers/runloop)

<!-- Logo -->

[![Blaxel logo](/blaxel-logo-light.svg)](/providers/blaxel)

<!-- Category Badge -->

[SANDBOXES](/providers/blaxel)

<!-- Provider Name -->

## [Blaxel](/providers/blaxel)

<!-- Description -->

[Blaxel is a serverless compute platform designed for AI workloads. On-demand GPU and CPU resources with automatic scaling.](/providers/blaxel)

<!-- Links -->

[ Docs](/providers/blaxel)

<!-- Provider CTA -->

For infrastructure providers: Want to offer best-in-class sandbox features to your users?

[Get in Touch ](/contact)

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# ComputeSDK + Blaxel Sandboxes

> Run serverless AI workloads with Blaxel and ComputeSDK. On-demand GPU and CPU resources with automatic scaling.

<!-- Back link -->

[ Back to Providers](/providers)

<!-- Logo Card -->

![Blaxel](/blaxel-logo-light.svg)

[ Docs](/docs/providers/blaxel/)

<!-- <a href="#" class="inline-flex items-center gap-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />
            </svg>
            Blog
          </a> -->

<!-- Content -->

# Blaxel

SANDBOXES

Blaxel is a serverless compute platform designed for AI workloads. It provides on-demand GPU and CPU resources with automatic scaling, enabling developers to run machine learning models and data processing tasks without managing infrastructure.

## Blaxel + ComputeSDK

ComputeSDK integrates with Blaxel to provide seamless access to serverless compute resources. This allows users to execute compute jobs directly through the SDK, leveraging Blaxel's infrastructure for scalable, on-demand processing without the complexity of server management.

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# ComputeSDK + CodeSandbox

> Run code in isolated sandbox environments with CodeSandbox and ComputeSDK. Secure, ephemeral containers for development.

<!-- Back link -->

[ Back to Providers](/providers)

<!-- Logo Card -->

![CodeSandbox](/codesandbox-logo-light.svg)

[ Docs](/docs/providers/codesandbox)

<!-- <a href="#" class="inline-flex items-center gap-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />
            </svg>
            Blog
          </a> -->

<!-- Content -->

# CodeSandbox

SANDBOXES

CodeSandbox is a cloud development platform that enables instant, collaborative coding environments. It provides sandboxed environments for web development with support for modern frameworks, allowing teams to prototype, share, and iterate on code directly in the browser.

## CodeSandbox + ComputeSDK

ComputeSDK integrates with CodeSandbox to provide isolated sandbox environments for code execution. This allows users to safely run and test code in ephemeral containers, leveraging CodeSandbox's infrastructure for secure, reproducible development environments.

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# ComputeSDK + Daytona Sandboxes

> Create reproducible dev environments with Daytona and ComputeSDK. Infrastructure-agnostic sandboxes for code execution.

<!-- Back link -->

[ Back to Providers](/providers)

<!-- Logo Card -->

![Daytona.io logo](/daytona-logo-light.svg)

[ Docs](/docs/providers/daytona)

<!-- <a href="#" class="inline-flex items-center gap-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />
            </svg>
            Blog
          </a> -->

<!-- Content -->

# Daytona

SANDBOXES

Daytona is an open-source development environment manager that creates standardized, reproducible dev environments. It supports multiple IDEs and Git providers, enabling teams to spin up consistent workspaces with a single command on any infrastructure.

## Daytona + ComputeSDK

ComputeSDK integrates with Daytona to provide flexible sandbox environments for code execution. This allows users to run code in fully configured development workspaces, leveraging Daytona's infrastructure-agnostic approach for consistent, reproducible compute environments.

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# ComputeSDK + E2B Sandboxes

> Run AI-generated code securely with E2B and ComputeSDK. Fast-spinning sandboxes built for LLM applications.

<!-- Back link -->

[ Back to Providers](/providers)

<!-- Logo Card -->

![E2B.dev logo](/E2B-logo-light.svg)

[ Docs](/docs/providers/e2b)

<!-- <a href="#" class="inline-flex items-center gap-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />
            </svg>
            Blog
          </a> -->

<!-- Content -->

# E2B

SANDBOXES

E2B is a cloud platform for running AI-generated code in secure sandboxes. It provides fast-spinning, isolated environments purpose-built for LLM applications, enabling AI agents and assistants to safely execute code with full system access.

## E2B + ComputeSDK

ComputeSDK integrates with E2B to provide secure sandbox environments optimized for AI code execution. This allows users to run untrusted code generated by LLMs in isolated containers, leveraging E2B's infrastructure for fast startup times and robust security boundaries.

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# ComputeSDK + Modal Sandboxes

> Run Python and ML workloads with Modal and ComputeSDK. Serverless compute with GPU support and fast cold starts.

<!-- Back link -->

[ Back to Providers](/providers)

<!-- Logo Card -->

![Modal logo](/modal-logo-light.svg)

[ Docs](/docs/providers/modal)

<!-- <a href="#" class="inline-flex items-center gap-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />
            </svg>
            Blog
          </a> -->

<!-- Content -->

# MODAL

SANDBOXES

Modal is a serverless cloud platform for running compute-intensive Python code. It provides instant container spin-up with GPU support, enabling developers to run ML inference, data processing, and batch jobs without managing infrastructure.

## Modal + ComputeSDK

ComputeSDK integrates with Modal to provide serverless compute environments with GPU acceleration. This allows users to execute Python code and ML workloads on-demand, leveraging Modal's infrastructure for fast cold starts and seamless scaling.

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# ComputeSDK + Runloop Sandboxes

> Run code in secure devboxes with Runloop and ComputeSDK. Isolated Linux environments for AI-assisted development.

<!-- Back link -->

[ Back to Providers](/providers)

<!-- Logo Card -->

![Runloop logo](/runloop-logo-light.svg)

[ Docs](/docs/providers/runloop)

<!-- <a href="#" class="inline-flex items-center gap-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />
            </svg>
            Blog
          </a> -->

<!-- Content -->

# RUNLOOP

SANDBOXES

Runloop is a cloud platform for running secure, isolated development environments. It provides instant devboxes with full Linux environments, enabling AI coding agents and developers to execute code, run tests, and build applications in sandboxed containers.

## Runloop + ComputeSDK

ComputeSDK integrates with Runloop to provide secure devbox environments for code execution. This allows users to run code in fully isolated Linux containers, leveraging Runloop's infrastructure for fast provisioning and robust security boundaries ideal for AI-assisted development.

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# ComputeSDK + Vercel Sandboxes

> Run AI-generated code with Vercel Sandbox and ComputeSDK. Secure execution on Vercel's edge infrastructure.

<!-- Back link -->

[ Back to Providers](/providers)

<!-- Logo Card -->

![Vercel logo](/vercel-logo-light.svg)

[ Docs](/docs/providers/vercel)

<!-- <a href="#" class="inline-flex items-center gap-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />
            </svg>
            Blog
          </a> -->

<!-- Content -->

# VERCEL

SANDBOXES

Vercel Sandbox is a secure code execution environment built for AI applications. It provides isolated containers for running untrusted code generated by LLMs, with built-in support for web technologies and instant startup times.

## Vercel Sandbox + ComputeSDK

ComputeSDK integrates with Vercel Sandbox to provide secure execution environments for AI-generated code. This allows users to safely run code in isolated containers, leveraging Vercel's edge infrastructure for low-latency execution and seamless integration with AI workflows.

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Sales

> Contact ComputeSDK sales with any questions or to talk through your use case.

## Talk with our Team

Schedule a meeting with our engineering team to discuss your needs and see how ComputeSDK can help accelerate your development.

<!-- Cal inline embed code begins -->

<!-- Cal inline embed code ends -->

### Contact Sales

Our engineering and sales team is available to discuss your needs and answer any questions you may have - <email@computesdk.com>. You can also checkout our [contact](/contact) page for more information on how to connect with our team.

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Terms of Service

# ComputeSDK Terms of Service

**Last Updated:** January 15, 2025

If you signed a separate Order Form to access ComputeSDK with the same account, and that agreement has not ended, the terms below do not apply to you. Instead, your separate Order Form applies to your use of the Product.

This Agreement is between Snelling, LLC and the company or person accessing or using the Cloud Service. This Agreement consists of: (1) the Order Form below and (2) the Framework Terms defined below.

If you are accessing or using the Cloud Service on behalf of your company, you represent that you are authorized to accept this Agreement on behalf of your company. By signing up, accessing, or using the Product, Customer indicates its acceptance of this Agreement and agrees to be bound by the terms and conditions of this Agreement.

## Cover Page

### Order Form

**Framework Terms:** This Order Form incorporates and is governed by the Framework Terms, which consists of the Key Terms below and the Common Paper [**Cloud Service Standard Terms Version 2.1**](https://commonpaper.com/standards/cloud-service-agreement/2.1), which are incorporated by reference. Any modifications to the Standard Terms made in the Cover Page below will control over conflicts with the Standard Terms. Capitalized words have the meanings given in the Cover Page or the Standard Terms.

**Cloud Service:** ComputeSDK provides a cloud-based development platform and SDK for building and deploying applications.

**Order Date:** The Effective Date

**Subscription Period:** One month

**Cloud Service Fees:** Certain parts of the Product have different pricing plans, which are available at ComputeSDK's pricing page. Customer will pay Snelling, LLC the applicable Fees based on the Product tier and Customer's usage. Snelling, LLC may update Product pricing by giving at least 30 days notice to Customer (including by email or notification within the Product), and the change will apply in the next Subscription Period.

**Payment Process:** Customer authorizes Snelling, LLC to bill and charge Customer's payment method on file monthly for immediate payment or deduction without further approval.

**Non-Renewal Notice Period:** At least 30 days before the end of the current Subscription Period.

**Use Limitations:** Customer may not use the Cloud Service to develop applications that violate applicable laws, infringe third-party rights, or engage in malicious activities including but not limited to cryptocurrency mining, distributed denial of service attacks, or unauthorized data collection.

**Technical Support:** Snelling, LLC provides technical support through documentation, community forums, and email support for paid plans. Enterprise customers receive priority support with guaranteed response times.

**SLA:** Snelling, LLC will maintain 99.9% uptime for the Cloud Service, measured monthly, with service credits available for outages exceeding this threshold.

**Professional Services:** Not applicable

### Key Terms

**Customer:** The company or person who accesses or uses the Product. If the person accepting this Agreement is doing so on behalf of a company, all use of the word "Customer" in the Agreement will mean that company.

**Provider:** Snelling, LLC

**Effective Date:** The date Customer first accepts this Agreement.

**Governing Law:** State of Delaware, United States

**Chosen Courts:** The courts (whether state, federal, or otherwise) located in Delaware, United States.

**Covered Claims:**

* **Provider Covered Claims:** Any action, proceeding, or claim that the Cloud Service, when used by Customer according to the terms of the Agreement, violates, misappropriates, or otherwise infringes upon a third party's intellectual property or other proprietary rights.
* **Customer Covered Claims:** Any action, proceeding, or claim (1) that the Customer Content, when used according to the terms of the Agreement, violates, misappropriates, or otherwise infringes upon a third party's intellectual property or other proprietary rights; and (2) arising from or relating to Customer's breach or alleged breach of Section 2.1 (Restrictions on Customer).

**General Cap Amount:** 1x the fees paid or payable by Customer to Snelling, LLC in the 12 month period immediately before the claim.

**Increased Claims:** Breach of Section 3 (Privacy & Security), Breach of Section 10 (Confidentiality), and Provider's indemnification obligations.

**Increased Cap Amount:** 2x the fees paid or payable by Customer to Snelling, LLC in the 12 month period immediately before the claim.

**Unlimited Claims:** Customer's breach of Section 2.1 (Restrictions on Customer) and either party's breach of Section 12 (Confidentiality).

**Additional Warranties:** Snelling, LLC warrants that the Product, when used as authorized by the Agreement, does not and will not infringe or misappropriate anyone else's copyright, trademark, or trade secret.

**Notice Address:**

* For **Snelling, LLC**: email\@computesdk.com
* For **Customer**: The main email address for Customer's account

#### Attachments, Supplements & Modifications

**DPA:** Snelling, LLC's Data Processing Agreement is available at \[URL] and incorporated by reference for customers subject to GDPR or other applicable data protection regulations.

**Security Policy:** Snelling, LLC will use commercially reasonable efforts to secure the Cloud Service from unauthorized access, alteration, or use and other unlawful tampering.

**Insurance Minimums:** Not applicable

**Changes to the Standard Terms:** None

## Standard Terms

The complete Standard Terms are incorporated by reference and can be found at: [Common Paper Cloud Service Standard Terms Version 2.1](https://commonpaper.com/standards/cloud-service-agreement/2.1)

## Contact Information

If you have any questions about these Terms of Service, please contact us at:

Email: email\@computesdk.com

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.

# Use Cases

> From AI coding assistants to educational platforms, ComputeSDK powers diverse applications that need secure, real-time code execution.

<!-- Use Cases Hero -->

## Use Cases

From AI coding assistants to educational platforms, ComputeSDK powers diverse applications that need secure, real-time code execution. See how developers are building the future of interactive computing.

[Get Started](https://console.computesdk.com/register) [Talk to Sales ‚Üí](/sales)

![Card stack pattern](/card-stack-light.svg) ![Card stack pattern](/card-stack-dark.svg)

<!-- Features Grid -->

### Create secure sandboxes for any application

* ![](/MaterialSymbolsDeployedCode.svg)

  AI Code Execution

  Power AI coding tools like Anything, Bolt.new, and Lovable. Compute provides the APIs and interfaces for LLMs to execute code, read output, and iterate in real-time. Stream terminal output, file changes, and execution results directly to AI models. Enable true AI pair programming with sandboxes that AI agents can actually control.

  ![](/MaterialSymbolsCodeBlocksOutlineSharp.svg)

  Code Playgrounds

  Build interactive coding environments like CodeSandbox or StackBlitz. Users edit code in the browser while Compute handles execution, file watching, and hot reload. Serve preview URLs instantly. Support any language or framework‚ÄîNode.js, Python, Go, Ruby‚Äîwith full terminal and package manager access.

  ![](/TdesignEducationFilled.svg)

  Educational Platforms

  Build hands-on coding courses like Scrimba, Codecademy, freeCodeCamp, or boot camp platforms. Students write code, run tests, and see results immediately without local setup. Instructors monitor progress, provide instant feedback, and share working environments. Eliminate "it works on my machine" problems forever.

  ![](/MaterialSymbolsDataTable.svg)

  Data Analysis & Notebooks

  Run Jupyter notebooks, R scripts, or data processing pipelines from the browser. Upload datasets via file APIs, execute analysis code, and watch output stream in real-time. Export results, share findings via public URLs, and reproduce analyses with complete environment isolation.

  ![](/MaterialSymbolsLightComputerSharp.svg)

  Interview & Assessment Platforms

  Build technical assessment tools like HackerRank, LeetCode, or Codility. Provide candidates with fully functional development environments during interviews. Evaluate real coding skills with actual compilers and runtimes. Record terminal sessions, review file changes, and assess problem-solving approaches.

## Ready to deploy sandboxes anywhere?

Build real-time code execution experiences, run AI-generated code, and more on your existing infrastructure.

[Get Started](https://console.computesdk.com/register) [Talk to Sales ‚Üí](/sales)

[Privacy Policy](/privacy) [Terms of Service](/terms) [Contact](/contact) [Blog](/blog)

[X  ](https://x.com/computesdk)[GitHub ](https://github.com/computesdk/computesdk)

¬© 2025 Snelling, LLC. All rights reserved.